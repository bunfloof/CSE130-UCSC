1
00:00:02,700 --> 00:00:05,600
foreign

2
00:00:13,980 --> 00:00:16,980
okay

3
00:00:18,180 --> 00:00:20,820
so we will have uh we will have a very

4
00:00:20,820 --> 00:00:23,220
quick review about the file systems when

5
00:00:23,220 --> 00:00:25,920
we start to the next chapter or as hot

6
00:00:25,920 --> 00:00:28,320
topics so file system I'm going to

7
00:00:28,320 --> 00:00:30,960
review all the key concepts of of the

8
00:00:30,960 --> 00:00:33,120
file systems okay

9
00:00:33,120 --> 00:00:35,120
um

10
00:01:00,960 --> 00:01:03,300
so when we are talking about file system

11
00:01:03,300 --> 00:01:06,240
the key concepts of the file systems is

12
00:01:06,240 --> 00:01:09,720
that we first look at it from the user's

13
00:01:09,720 --> 00:01:12,119
point of view and when we see the file

14
00:01:12,119 --> 00:01:15,180
systems we actually see it as a tree

15
00:01:15,180 --> 00:01:17,840
structure

16
00:01:19,759 --> 00:01:23,159
and are surrounding about around this

17
00:01:23,159 --> 00:01:25,799
tree structure we have we have learned a

18
00:01:25,799 --> 00:01:28,320
lot of fire operations

19
00:01:28,320 --> 00:01:31,080
like create a file delete a file

20
00:01:31,080 --> 00:01:35,040
copy or file so those are file

21
00:01:35,040 --> 00:01:37,439
operations

22
00:01:37,439 --> 00:01:40,140
so that is all from the system point of

23
00:01:40,140 --> 00:01:42,320
view

24
00:01:43,320 --> 00:01:46,500
this is the um the file attributes and

25
00:01:46,500 --> 00:01:49,820
also the file operations

26
00:01:51,299 --> 00:01:53,060
so you do not need to remember

27
00:01:53,060 --> 00:01:56,220
everything of it you do not need to

28
00:01:56,220 --> 00:01:57,659
remember because

29
00:01:57,659 --> 00:01:59,520
they are very

30
00:01:59,520 --> 00:02:02,399
frequently used but here you need to

31
00:02:02,399 --> 00:02:04,560
remember is that all the file operations

32
00:02:04,560 --> 00:02:09,479
are were in or trigger system course

33
00:02:09,479 --> 00:02:13,020
so any students know why why why every

34
00:02:13,020 --> 00:02:14,879
almost every file operations will

35
00:02:14,879 --> 00:02:17,879
trigger the system core

36
00:02:17,879 --> 00:02:21,379
so have you think about that

37
00:02:22,860 --> 00:02:25,080
so when we talk about when we learn file

38
00:02:25,080 --> 00:02:27,599
system we we when we learn our first

39
00:02:27,599 --> 00:02:29,879
lesson we learned that ours is an

40
00:02:29,879 --> 00:02:31,739
abstraction and resource manager right

41
00:02:31,739 --> 00:02:35,099
and then a file file system is the

42
00:02:35,099 --> 00:02:37,620
abstraction of the disk right

43
00:02:37,620 --> 00:02:40,379
the hardware is a disk and the file

44
00:02:40,379 --> 00:02:44,599
system is the abstraction of the disk

45
00:02:44,940 --> 00:02:47,940
so if you look at these operations so

46
00:02:47,940 --> 00:02:51,180
create these open close read write there

47
00:02:51,180 --> 00:02:54,120
they're almost all operations

48
00:02:54,120 --> 00:02:57,300
about how you're going to manipulate the

49
00:02:57,300 --> 00:03:00,060
space in the disk how user going to

50
00:03:00,060 --> 00:03:04,860
interact with the hardware user user and

51
00:03:04,860 --> 00:03:07,800
the hardware and the OS is in the middle

52
00:03:07,800 --> 00:03:09,840
right OS providing the beautiful

53
00:03:09,840 --> 00:03:14,220
interfaces for the users for the ugly

54
00:03:14,220 --> 00:03:16,140
Hardware that is what we learned in the

55
00:03:16,140 --> 00:03:19,800
first lesson so that is why almost file

56
00:03:19,800 --> 00:03:21,540
operations will trigger the system core

57
00:03:21,540 --> 00:03:24,540
because these operations almost all of

58
00:03:24,540 --> 00:03:26,940
these operations user needs to interact

59
00:03:26,940 --> 00:03:29,940
with the hardware Hardware of the disk

60
00:03:29,940 --> 00:03:33,300
right and Os is obstruction of the disk

61
00:03:33,300 --> 00:03:35,459
OS provides the file system as

62
00:03:35,459 --> 00:03:37,440
obstruction of the disk that is why

63
00:03:37,440 --> 00:03:40,379
they're all equals trigger the system

64
00:03:40,379 --> 00:03:42,799
core

65
00:03:44,580 --> 00:03:46,860
and then we learn the directories I've

66
00:03:46,860 --> 00:03:48,840
already told you that directory is a

67
00:03:48,840 --> 00:03:51,959
special form of file so if we look at

68
00:03:51,959 --> 00:03:53,819
the system point we will see the

69
00:03:53,819 --> 00:03:55,379
directory and the files they are

70
00:03:55,379 --> 00:03:59,000
actually using the same data structure

71
00:03:59,280 --> 00:04:01,680
and then what's the differences between

72
00:04:01,680 --> 00:04:05,040
the absolute past and the

73
00:04:05,040 --> 00:04:07,920
relative path

74
00:04:07,920 --> 00:04:11,480
what is absolute path

75
00:04:12,120 --> 00:04:14,519
so this is all from the user's point of

76
00:04:14,519 --> 00:04:16,440
view what is the absolute path of the

77
00:04:16,440 --> 00:04:18,979
file system

78
00:04:19,560 --> 00:04:21,779
yeah I start with the loot right when we

79
00:04:21,779 --> 00:04:23,460
when you when you need to locate the

80
00:04:23,460 --> 00:04:27,000
file you start searching it sorry it's

81
00:04:27,000 --> 00:04:29,220
you locate a file

82
00:04:29,220 --> 00:04:30,540
then you

83
00:04:30,540 --> 00:04:35,160
naming that file from the root directory

84
00:04:35,160 --> 00:04:37,680
so that is the past names right we have

85
00:04:37,680 --> 00:04:39,419
the absolute past that's the absolute

86
00:04:39,419 --> 00:04:43,220
path and then what is a relative path

87
00:04:46,020 --> 00:04:50,280
so there's the absolute absolute path

88
00:04:50,280 --> 00:04:53,100
one of file system is organized also or

89
00:04:53,100 --> 00:04:55,860
directory tree right there's two ways of

90
00:04:55,860 --> 00:04:58,259
specifying file names one is we starting

91
00:04:58,259 --> 00:05:01,500
from the loot directory and we look the

92
00:05:01,500 --> 00:05:03,120
loop directory

93
00:05:03,120 --> 00:05:06,360
let's say if I want to find I want to I

94
00:05:06,360 --> 00:05:08,580
want to have the name absolute past

95
00:05:08,580 --> 00:05:11,340
names of this file a we can I can start

96
00:05:11,340 --> 00:05:13,020
from the loot directory then I can

97
00:05:13,020 --> 00:05:17,479
locate that file another way that

98
00:05:20,280 --> 00:05:21,600
are

99
00:05:21,600 --> 00:05:23,759
passed from

100
00:05:23,759 --> 00:05:25,620
root filed and

101
00:05:25,620 --> 00:05:30,680
the relative past might just be part of

102
00:05:37,259 --> 00:05:39,620
the only way

103
00:05:39,720 --> 00:05:44,300
yeah where are you currently it is right

104
00:05:46,380 --> 00:05:48,539
so absolute passes from the loot

105
00:05:48,539 --> 00:05:51,300
directory and the relative pass starts

106
00:05:51,300 --> 00:05:54,180
from the current position where you

107
00:05:54,180 --> 00:05:56,100
currently is and with the let's say we

108
00:05:56,100 --> 00:05:59,220
are in this folder then we can get a

109
00:05:59,220 --> 00:06:00,600
file so that's the difference between

110
00:06:00,600 --> 00:06:02,639
absolute past and uh

111
00:06:02,639 --> 00:06:06,120
on the relative path

112
00:06:06,120 --> 00:06:08,820
we also have many directory operations

113
00:06:08,820 --> 00:06:10,740
directory operations

114
00:06:10,740 --> 00:06:13,820
so let's starting from the Implement

115
00:06:13,820 --> 00:06:16,080
implementer's point of views or the

116
00:06:16,080 --> 00:06:17,220
system

117
00:06:17,220 --> 00:06:18,840
when we do the system into

118
00:06:18,840 --> 00:06:21,180
implementation

119
00:06:21,180 --> 00:06:21,900
um

120
00:06:21,900 --> 00:06:25,620
so how do we Implement a file system in

121
00:06:25,620 --> 00:06:27,840
that case that is what we learned in our

122
00:06:27,840 --> 00:06:29,940
last lecture

123
00:06:29,940 --> 00:06:32,580
because it's been several days you may

124
00:06:32,580 --> 00:06:35,280
already forget it so let's first look at

125
00:06:35,280 --> 00:06:36,960
this picture

126
00:06:36,960 --> 00:06:39,960
so this is a personal file system layout

127
00:06:39,960 --> 00:06:43,199
so this is here this is the entire disk

128
00:06:43,199 --> 00:06:46,560
we see an entire disk and we for the

129
00:06:46,560 --> 00:06:49,520
entire disk

130
00:06:50,280 --> 00:06:52,560
let's say that this conceit right you

131
00:06:52,560 --> 00:06:55,500
need to for the disk this case like is

132
00:06:55,500 --> 00:06:58,199
it looks like this this is a disk right

133
00:06:58,199 --> 00:07:00,900
this is a disk so when we're talking

134
00:07:00,900 --> 00:07:03,960
about this could be first thing is to

135
00:07:03,960 --> 00:07:07,020
cartridge into many partitions right we

136
00:07:07,020 --> 00:07:09,840
cut it into many partitions and inside

137
00:07:09,840 --> 00:07:12,979
of each partition

138
00:07:14,759 --> 00:07:17,340
then they have this data structure this

139
00:07:17,340 --> 00:07:19,380
is a structure

140
00:07:19,380 --> 00:07:23,520
so what is the block put block put block

141
00:07:23,520 --> 00:07:25,860
so when we talk about block we need to

142
00:07:25,860 --> 00:07:30,259
know that block what is exactly a block

143
00:07:30,319 --> 00:07:34,800
is the units you you we used in a file

144
00:07:34,800 --> 00:07:38,280
system to store files it's similar to

145
00:07:38,280 --> 00:07:39,539
the page

146
00:07:39,539 --> 00:07:42,060
in memory similar to the page the

147
00:07:42,060 --> 00:07:43,740
concept of the page in the memory

148
00:07:43,740 --> 00:07:46,620
chapter but in the in the in the file

149
00:07:46,620 --> 00:07:49,259
system we call it every unit that we

150
00:07:49,259 --> 00:07:51,599
used to store files it's called a block

151
00:07:51,599 --> 00:07:56,479
a block a block you can single block

152
00:07:57,780 --> 00:08:02,039
usually is 64 megabytes

153
00:08:02,039 --> 00:08:05,759
so some some system 30 to 16 megabytes

154
00:08:05,759 --> 00:08:07,680
it depends on different operating

155
00:08:07,680 --> 00:08:10,740
systems and we have the boot block is

156
00:08:10,740 --> 00:08:13,740
the starting start is the start of the

157
00:08:13,740 --> 00:08:16,259
of the of the

158
00:08:16,259 --> 00:08:18,660
of the disk partition right the start

159
00:08:18,660 --> 00:08:22,160
block of the this partition

160
00:08:27,300 --> 00:08:29,460
and then we have the super block so

161
00:08:29,460 --> 00:08:31,860
super block have a includes a magic

162
00:08:31,860 --> 00:08:34,500
number to include

163
00:08:34,500 --> 00:08:37,500
to identify the file system type the

164
00:08:37,500 --> 00:08:40,080
file system type we can have many type

165
00:08:40,080 --> 00:08:42,299
of different file systems so

166
00:08:42,299 --> 00:08:44,760
and the number of blocks in the file

167
00:08:44,760 --> 00:08:47,760
system and the other key administrative

168
00:08:47,760 --> 00:08:50,760
information in next common information

169
00:08:50,760 --> 00:08:53,339
is that it's very important concept

170
00:08:53,339 --> 00:08:57,420
after the Super block we have the

171
00:08:57,420 --> 00:09:01,140
I node inodes I nodes so what is exactly

172
00:09:01,140 --> 00:09:03,660
I know let's say another key Concept in

173
00:09:03,660 --> 00:09:06,380
the file system

174
00:09:06,600 --> 00:09:09,600
so what exactly is our eye notes

175
00:09:09,600 --> 00:09:11,600
um

176
00:09:12,240 --> 00:09:15,000
it's a number that corresponds to a

177
00:09:15,000 --> 00:09:18,060
specific file it's not a number it's not

178
00:09:18,060 --> 00:09:21,300
a number what is I know

179
00:09:21,300 --> 00:09:24,140
yes Lily

180
00:09:26,660 --> 00:09:29,880
I'm sorry

181
00:09:29,880 --> 00:09:32,160
yeah it stores the index information

182
00:09:32,160 --> 00:09:35,580
about the about the files right each

183
00:09:35,580 --> 00:09:39,000
file has a in in I node right and then

184
00:09:39,000 --> 00:09:41,399
what's the information is stored what's

185
00:09:41,399 --> 00:09:44,839
the information is source

186
00:09:47,240 --> 00:09:50,279
every file has an i node a directory

187
00:09:50,279 --> 00:09:52,080
also has an inode

188
00:09:52,080 --> 00:09:55,519
that is what yes

189
00:09:59,100 --> 00:10:01,980
location of the oh okay it's not a

190
00:10:01,980 --> 00:10:05,180
location of the memory

191
00:10:05,959 --> 00:10:08,459
no it's not a location on the virtual

192
00:10:08,459 --> 00:10:10,920
memory we we are in the file system

193
00:10:10,920 --> 00:10:12,899
chapter right file system is the

194
00:10:12,899 --> 00:10:17,040
abstraction of disk disk

195
00:10:17,040 --> 00:10:20,040
right yeah

196
00:10:20,040 --> 00:10:22,440
mm-hmm

197
00:10:22,440 --> 00:10:26,839
permission yes then what else

198
00:10:31,880 --> 00:10:35,640
what else what else I know

199
00:10:35,640 --> 00:10:37,500
when we're talking about absolute past

200
00:10:37,500 --> 00:10:39,720
and relative paths we all look at it

201
00:10:39,720 --> 00:10:43,200
from the user's point of view but

202
00:10:43,200 --> 00:10:45,420
actually the file can be very large your

203
00:10:45,420 --> 00:10:47,820
movie is 10 gigabytes of movie you

204
00:10:47,820 --> 00:10:49,980
cannot store that in one

205
00:10:49,980 --> 00:10:53,360
place right Eric

206
00:10:59,700 --> 00:11:01,640
um

207
00:11:01,640 --> 00:11:05,279
very good very good so a file a file

208
00:11:05,279 --> 00:11:07,980
will be divided into many blocks blocks

209
00:11:07,980 --> 00:11:10,620
blocks is the units the smallest units

210
00:11:10,620 --> 00:11:14,160
that we store the files in the disk

211
00:11:14,160 --> 00:11:17,339
right and so a file can be broken into

212
00:11:17,339 --> 00:11:20,700
many blocks then I know there was slowly

213
00:11:20,700 --> 00:11:23,519
address information about where exactly

214
00:11:23,519 --> 00:11:27,480
each block is physically in the disk so

215
00:11:27,480 --> 00:11:30,320
it was it was stored mapping from the

216
00:11:30,320 --> 00:11:32,760
the block number the virtual block

217
00:11:32,760 --> 00:11:34,920
number two the physical block number it

218
00:11:34,920 --> 00:11:37,440
will shows like the where is the

219
00:11:37,440 --> 00:11:39,959
partition with the section number so

220
00:11:39,959 --> 00:11:42,000
if we look at the hardware you can see

221
00:11:42,000 --> 00:11:43,620
that this is the partition right then

222
00:11:43,620 --> 00:11:48,860
there's a section and there's offset yes

223
00:11:53,279 --> 00:11:56,339
yeah very good very good if if the if

224
00:11:56,339 --> 00:11:58,800
the file is very big if a file is very

225
00:11:58,800 --> 00:12:01,320
big then the inode maybe have several

226
00:12:01,320 --> 00:12:03,899
layers if it has several layers then the

227
00:12:03,899 --> 00:12:06,600
first I know points to the next level I

228
00:12:06,600 --> 00:12:09,000
know that store the rest of the files

229
00:12:09,000 --> 00:12:10,140
information

230
00:12:10,140 --> 00:12:13,320
rest of that file so each file has a one

231
00:12:13,320 --> 00:12:15,899
eye node that's why and then we see this

232
00:12:15,899 --> 00:12:19,579
is this s here s

233
00:12:20,660 --> 00:12:23,760
why this is why there's s because in the

234
00:12:23,760 --> 00:12:25,560
disk in the disk partition this

235
00:12:25,560 --> 00:12:27,720
partition there's tens of thousands of

236
00:12:27,720 --> 00:12:29,820
files right there are many files each

237
00:12:29,820 --> 00:12:32,279
file has a specific I node then we put

238
00:12:32,279 --> 00:12:34,740
the inode there we put the I know there

239
00:12:34,740 --> 00:12:38,100
and then starting from the next the next

240
00:12:38,100 --> 00:12:40,079
wrestle place we store the Rook

241
00:12:40,079 --> 00:12:43,700
directory yet at Endura

242
00:12:47,660 --> 00:12:51,720
MBR is the it's because the um

243
00:12:51,720 --> 00:12:53,519
oh I forgot the name it's called The

244
00:12:53,519 --> 00:12:56,639
Master boot uh yeah rockers yeah yes

245
00:12:56,639 --> 00:12:58,980
yeah Master boost records is used for

246
00:12:58,980 --> 00:13:02,639
launching Lodge the operating system is

247
00:13:02,639 --> 00:13:05,399
the starting so so useful for the BIOS

248
00:13:05,399 --> 00:13:07,920
right you have the BIOS you need to you

249
00:13:07,920 --> 00:13:10,019
this is the entry of the operating

250
00:13:10,019 --> 00:13:12,360
system when you power it on

251
00:13:12,360 --> 00:13:14,820
then operating system goes there because

252
00:13:14,820 --> 00:13:17,700
they are rebooting it there's a master

253
00:13:17,700 --> 00:13:20,839
boot records

254
00:13:23,339 --> 00:13:26,060
yeah Andrew

255
00:13:34,399 --> 00:13:38,459
yes it is it is so the sick the order

256
00:13:38,459 --> 00:13:39,959
will not change

257
00:13:39,959 --> 00:13:42,959
we always it's like a book you cannot

258
00:13:42,959 --> 00:13:45,300
save the index information of the book

259
00:13:45,300 --> 00:13:47,820
at the end of the book you always

260
00:13:47,820 --> 00:13:50,220
you always puts the preface right in the

261
00:13:50,220 --> 00:13:52,560
book if we open a book we see what is

262
00:13:52,560 --> 00:13:54,720
the first page the first page you should

263
00:13:54,720 --> 00:13:57,120
will show the orders right who is the

264
00:13:57,120 --> 00:14:00,360
Watchers and the pictures and maybe some

265
00:14:00,360 --> 00:14:02,399
numbers regarding the book and then the

266
00:14:02,399 --> 00:14:04,800
next page is preface right preface is

267
00:14:04,800 --> 00:14:06,600
like the MBR

268
00:14:06,600 --> 00:14:08,540
it's like the starting of the book

269
00:14:08,540 --> 00:14:11,459
preface like shows some story of why I

270
00:14:11,459 --> 00:14:14,160
wrote this book and then starting there

271
00:14:14,160 --> 00:14:16,920
we have the chap we have the index index

272
00:14:16,920 --> 00:14:18,839
of each chapter where each chapter is

273
00:14:18,839 --> 00:14:22,380
that is like this like like this

274
00:14:22,380 --> 00:14:24,899
so everything in operation system using

275
00:14:24,899 --> 00:14:26,459
a structure

276
00:14:26,459 --> 00:14:30,720
from the uh a big summary and then

277
00:14:30,720 --> 00:14:36,120
each uh each uh independent details the

278
00:14:36,120 --> 00:14:38,160
same thing like file system in almost in

279
00:14:38,160 --> 00:14:41,160
every file systems when we see a disk

280
00:14:41,160 --> 00:14:43,320
competition we see that this is the

281
00:14:43,320 --> 00:14:45,660
whole disc like this partition with we

282
00:14:45,660 --> 00:14:48,380
want to see the

283
00:14:48,779 --> 00:14:50,760
this the I know the information first

284
00:14:50,760 --> 00:14:53,279
and then each files information okay

285
00:14:53,279 --> 00:14:56,240
each files information

286
00:14:59,639 --> 00:15:01,860
before we're talking about I know we

287
00:15:01,860 --> 00:15:04,680
talk about several different approaches

288
00:15:04,680 --> 00:15:07,500
that we used to managing the free

289
00:15:07,500 --> 00:15:11,279
available spaces in the disk in this so

290
00:15:11,279 --> 00:15:13,740
I noticed the last option but then we

291
00:15:13,740 --> 00:15:15,000
also talking about continually

292
00:15:15,000 --> 00:15:17,639
allocation linked list or location and

293
00:15:17,639 --> 00:15:19,500
when we're talking about that for the

294
00:15:19,500 --> 00:15:21,740
continual location it has the

295
00:15:21,740 --> 00:15:24,920
disadvantage of creating a lot of

296
00:15:24,920 --> 00:15:28,079
internal fragmentations right but the

297
00:15:28,079 --> 00:15:30,120
good thing about that is very easy to

298
00:15:30,120 --> 00:15:32,519
implement very easy to implement and

299
00:15:32,519 --> 00:15:36,199
what else the good thing about that

300
00:15:36,300 --> 00:15:40,040
the good thing about that

301
00:15:40,380 --> 00:15:42,300
yes

302
00:15:42,300 --> 00:15:44,579
goodread performance random read access

303
00:15:44,579 --> 00:15:47,399
is also good okay read performance is

304
00:15:47,399 --> 00:15:50,100
very good why because because the files

305
00:15:50,100 --> 00:15:52,079
is stored together physically together

306
00:15:52,079 --> 00:15:54,959
they are stored this is a file

307
00:15:54,959 --> 00:15:58,079
there are virtually when we we see the

308
00:15:58,079 --> 00:16:00,420
file we definitely see a file as a whole

309
00:16:00,420 --> 00:16:03,959
we see I see a movie is just

310
00:16:03,959 --> 00:16:07,260
a logo of the movie and then it's like

311
00:16:07,260 --> 00:16:10,560
MP4 like that is my movie Once the movie

312
00:16:10,560 --> 00:16:13,019
is a whole but physically it's also

313
00:16:13,019 --> 00:16:15,660
stored as a whole it is a continually

314
00:16:15,660 --> 00:16:18,180
allocation approach continuing education

315
00:16:18,180 --> 00:16:21,839
approach so it's very easy to implement

316
00:16:21,839 --> 00:16:24,000
the reader performance the random grid

317
00:16:24,000 --> 00:16:26,519
performance random read access is super

318
00:16:26,519 --> 00:16:28,800
good why because you

319
00:16:28,800 --> 00:16:33,060
you locate the beginning of a big file

320
00:16:33,060 --> 00:16:35,459
then you just need to know the size of

321
00:16:35,459 --> 00:16:37,920
the file then you can almost point to

322
00:16:37,920 --> 00:16:40,860
any position in the file because you

323
00:16:40,860 --> 00:16:42,420
already know the beginning of the file

324
00:16:42,420 --> 00:16:44,459
the beginning of the file is just the

325
00:16:44,459 --> 00:16:46,800
plus the offset then you can jump to any

326
00:16:46,800 --> 00:16:48,420
position of the file so the read

327
00:16:48,420 --> 00:16:50,820
performance is good is great

328
00:16:50,820 --> 00:16:53,639
and then the bad thing about that the

329
00:16:53,639 --> 00:16:55,860
disk becomes fragmented over time so

330
00:16:55,860 --> 00:16:56,759
because

331
00:16:56,759 --> 00:16:59,639
so that is why we use continual occasion

332
00:16:59,639 --> 00:17:02,220
not in modern operating system but we

333
00:17:02,220 --> 00:17:06,720
use that in some like DVD or CD

334
00:17:06,720 --> 00:17:10,919
there are Futures is that they are

335
00:17:10,919 --> 00:17:13,319
they are read only right you cannot you

336
00:17:13,319 --> 00:17:15,179
cannot you

337
00:17:15,179 --> 00:17:18,359
it's like you almost like uh I don't

338
00:17:18,359 --> 00:17:20,579
know if you are familiar with the CD-ROM

339
00:17:20,579 --> 00:17:23,939
I used to uh

340
00:17:23,939 --> 00:17:28,679
to to user user to play with it for a

341
00:17:28,679 --> 00:17:31,919
long time it's in when I was 18. I

342
00:17:31,919 --> 00:17:34,740
listened to the music and I have

343
00:17:34,740 --> 00:17:37,799
I bought a lot of CDs and also why why

344
00:17:37,799 --> 00:17:40,679
why we use continue allocation approach

345
00:17:40,679 --> 00:17:44,640
to in this material because when you

346
00:17:44,640 --> 00:17:46,980
listen to the music you you loaded a lot

347
00:17:46,980 --> 00:17:48,419
and you

348
00:17:48,419 --> 00:17:50,400
you just need to

349
00:17:50,400 --> 00:17:54,360
listen the music like one by one and you

350
00:17:54,360 --> 00:17:57,000
readily change it

351
00:17:57,000 --> 00:17:59,520
and then we talk about another another

352
00:17:59,520 --> 00:18:01,799
location approach linked list of pro

353
00:18:01,799 --> 00:18:03,360
approach

354
00:18:03,360 --> 00:18:06,000
so lingerless approach is the good thing

355
00:18:06,000 --> 00:18:08,400
that is get rid of fragmentation but the

356
00:18:08,400 --> 00:18:10,679
random access is slow it's slow because

357
00:18:10,679 --> 00:18:12,720
you need to change the pointers to get

358
00:18:12,720 --> 00:18:15,179
to a block think of that so you I need

359
00:18:15,179 --> 00:18:17,520
to get the end of the file so I only

360
00:18:17,520 --> 00:18:19,320
know the beginning of the file then I

361
00:18:19,320 --> 00:18:22,799
have to I have to chase it Chase it one

362
00:18:22,799 --> 00:18:25,440
by one jump it one by one because I will

363
00:18:25,440 --> 00:18:27,900
never know where it ends so that's why

364
00:18:27,900 --> 00:18:30,120
that's why I know the approach got

365
00:18:30,120 --> 00:18:32,700
developed right okay I know the approach

366
00:18:32,700 --> 00:18:35,419
got developed

367
00:18:35,880 --> 00:18:37,140
so

368
00:18:37,140 --> 00:18:39,140
um

369
00:18:39,179 --> 00:18:42,240
the the good things about I node is that

370
00:18:42,240 --> 00:18:44,460
the good things about I noticed that we

371
00:18:44,460 --> 00:18:46,500
already know the files is broken into

372
00:18:46,500 --> 00:18:49,200
many blocks so I know to save the

373
00:18:49,200 --> 00:18:53,280
location of each block right of each

374
00:18:53,280 --> 00:18:56,400
block then you only need to load I node

375
00:18:56,400 --> 00:18:58,679
this I know data structure into the

376
00:18:58,679 --> 00:19:01,980
memory you whenever you need to you need

377
00:19:01,980 --> 00:19:04,740
to look at any position read any

378
00:19:04,740 --> 00:19:06,960
position of the file you just need to

379
00:19:06,960 --> 00:19:09,600
load it into memory then you almost know

380
00:19:09,600 --> 00:19:10,799
every

381
00:19:10,799 --> 00:19:13,440
part of the file for example if the file

382
00:19:13,440 --> 00:19:16,799
has Ace blocks I need this is a movie I

383
00:19:16,799 --> 00:19:19,620
want to see the middle of the movie then

384
00:19:19,620 --> 00:19:22,799
I just need to check that I know this I

385
00:19:22,799 --> 00:19:24,720
know the data structure I just checked

386
00:19:24,720 --> 00:19:26,940
okay give me the address of the diesel

387
00:19:26,940 --> 00:19:31,880
block 4. this or this block 3

388
00:19:32,280 --> 00:19:34,559
give me this position right the address

389
00:19:34,559 --> 00:19:36,900
the address is the physical address is

390
00:19:36,900 --> 00:19:40,740
the disk address so I only needs to load

391
00:19:40,740 --> 00:19:43,559
that in your memory and then ask it ask

392
00:19:43,559 --> 00:19:46,740
it can you give me that

393
00:19:46,740 --> 00:19:48,900
address

394
00:19:48,900 --> 00:19:50,220
then

395
00:19:50,220 --> 00:19:52,620
then after I got a physical address the

396
00:19:52,620 --> 00:19:54,780
physical address will be looks like okay

397
00:19:54,780 --> 00:19:56,280
the partition number the section number

398
00:19:56,280 --> 00:19:59,460
the offset then I can directly points to

399
00:19:59,460 --> 00:20:01,380
that I can answer my operations from the

400
00:20:01,380 --> 00:20:02,880
point that it's very easy so the read

401
00:20:02,880 --> 00:20:05,039
performance is good right the read

402
00:20:05,039 --> 00:20:07,460
performance is good it also reduce

403
00:20:07,460 --> 00:20:11,039
reduce the internal fragmentations why

404
00:20:11,039 --> 00:20:12,360
it should reduce the internal

405
00:20:12,360 --> 00:20:14,280
fragmentations any students think of

406
00:20:14,280 --> 00:20:16,520
that

407
00:20:17,700 --> 00:20:20,480
Maja

408
00:20:23,640 --> 00:20:25,980
a smaller block a blocking from like a

409
00:20:25,980 --> 00:20:28,500
smaller Gap in the whole aisle yes files

410
00:20:28,500 --> 00:20:30,900
is divided in it's broken into many

411
00:20:30,900 --> 00:20:33,480
blocks right It's let's say for um I

412
00:20:33,480 --> 00:20:37,559
have a 1000 megabytes of file each each

413
00:20:37,559 --> 00:20:40,620
blocks is 84 megabytes then I divide it

414
00:20:40,620 --> 00:20:43,200
then I I know how many blocks that I

415
00:20:43,200 --> 00:20:46,740
need then these blocks are spread over

416
00:20:46,740 --> 00:20:49,799
all this it can be anywhere so whenever

417
00:20:49,799 --> 00:20:54,000
it has empty place and it can fix that

418
00:20:54,000 --> 00:20:56,100
blocks I can put that

419
00:20:56,100 --> 00:20:59,880
it's it's it effectively reduce the

420
00:20:59,880 --> 00:21:02,460
internal fragmentation so I know this

421
00:21:02,460 --> 00:21:04,440
approach that

422
00:21:04,440 --> 00:21:08,100
combine the benefits the advantages of

423
00:21:08,100 --> 00:21:10,559
continually location approach and linked

424
00:21:10,559 --> 00:21:12,840
list approach

425
00:21:12,840 --> 00:21:15,260
okay

426
00:21:15,360 --> 00:21:18,179
so in so you need to understand this

427
00:21:18,179 --> 00:21:20,280
story right because we are learning a

428
00:21:20,280 --> 00:21:22,320
computer system as a class this system

429
00:21:22,320 --> 00:21:25,980
you need to have a you I hope that you

430
00:21:25,980 --> 00:21:29,159
do not just memorize in these Concepts

431
00:21:29,159 --> 00:21:31,620
you need to understand it in the exam I

432
00:21:31,620 --> 00:21:34,020
may give you a question like ask you to

433
00:21:34,020 --> 00:21:37,320
design a file system that fits my needs

434
00:21:37,320 --> 00:21:40,140
I will tell you what I need and then you

435
00:21:40,140 --> 00:21:41,940
think of approach that you learn from

436
00:21:41,940 --> 00:21:44,720
this course to design it okay

437
00:21:44,720 --> 00:21:48,240
so uh try to understand the advantage

438
00:21:48,240 --> 00:21:50,700
and disadvantage of each Pro each of

439
00:21:50,700 --> 00:21:53,659
each approach okay

440
00:21:55,080 --> 00:21:57,620
oh

441
00:22:00,659 --> 00:22:03,799
let's go to this

442
00:22:04,200 --> 00:22:07,400
okay and then we're talking about the

443
00:22:07,400 --> 00:22:12,960
shared file share file when one

444
00:22:12,960 --> 00:22:15,780
for several users are going to share the

445
00:22:15,780 --> 00:22:18,000
same file the same file

446
00:22:18,000 --> 00:22:20,640
then how you how how can the operating

447
00:22:20,640 --> 00:22:23,460
system manage it because if in many

448
00:22:23,460 --> 00:22:26,520
let's say we we three people are working

449
00:22:26,520 --> 00:22:28,440
on the same projects and we share some

450
00:22:28,440 --> 00:22:32,460
files right so if I'm the only one

451
00:22:32,460 --> 00:22:34,559
if I'm the only one to delete the file

452
00:22:34,559 --> 00:22:36,539
you guys should not be affected because

453
00:22:36,539 --> 00:22:38,280
you are also working on that that

454
00:22:38,280 --> 00:22:40,200
folders right you may need to keep that

455
00:22:40,200 --> 00:22:42,480
file so how the operating system know

456
00:22:42,480 --> 00:22:45,419
that the file is no longer leaded by

457
00:22:45,419 --> 00:22:48,360
anyone that who is want to share in this

458
00:22:48,360 --> 00:22:51,240
file then we we have the new Concepts

459
00:22:51,240 --> 00:22:53,520
it's called reference cons reference

460
00:22:53,520 --> 00:22:57,419
counts and this reference comes

461
00:22:57,419 --> 00:22:59,940
um this is a very simple data structure

462
00:22:59,940 --> 00:23:02,159
it's just adding a variable in the inode

463
00:23:02,159 --> 00:23:04,559
the I know the data structure but it's

464
00:23:04,559 --> 00:23:06,900
very useful so the reference console

465
00:23:06,900 --> 00:23:09,360
will give you the information about how

466
00:23:09,360 --> 00:23:11,280
many people are currently share these

467
00:23:11,280 --> 00:23:13,860
files and while each turns on zero when

468
00:23:13,860 --> 00:23:16,559
it turns on zero that means no one no

469
00:23:16,559 --> 00:23:19,020
one is using their file anymore everyone

470
00:23:19,020 --> 00:23:20,720
is already

471
00:23:20,720 --> 00:23:23,580
planning to delete that file then the

472
00:23:23,580 --> 00:23:25,380
disks are going to recycle in that file

473
00:23:25,380 --> 00:23:27,000
okay

474
00:23:27,000 --> 00:23:30,679
so that is the reference count

475
00:23:43,559 --> 00:23:45,299
so okay so let's

476
00:23:45,299 --> 00:23:48,299
uh

477
00:23:51,360 --> 00:23:54,020
so let's review the steps in looking

478
00:23:54,020 --> 00:23:57,780
looking up this directory this is our

479
00:23:57,780 --> 00:24:01,200
absolute spot s absolute parts so we

480
00:24:01,200 --> 00:24:06,020
first what we do okay before that we

481
00:24:11,340 --> 00:24:13,380
what is I know the table we mentioned

482
00:24:13,380 --> 00:24:16,740
that in our last class I know the table

483
00:24:16,740 --> 00:24:18,720
any student remember we know that I know

484
00:24:18,720 --> 00:24:21,000
the right I know that I know to save the

485
00:24:21,000 --> 00:24:23,280
fire attributes and the block address of

486
00:24:23,280 --> 00:24:26,580
that file then what is inode table

487
00:24:26,580 --> 00:24:29,659
what is that I know the table

488
00:24:30,299 --> 00:24:32,840
yes

489
00:24:35,840 --> 00:24:39,919
directory of the inode

490
00:24:47,580 --> 00:24:52,039
what is I note I Note Everything

491
00:25:02,640 --> 00:25:04,640
um

492
00:25:05,419 --> 00:25:08,520
yes okay yes so here's the thing why we

493
00:25:08,520 --> 00:25:10,140
need I know the table if you look at

494
00:25:10,140 --> 00:25:13,280
this picture you see

495
00:25:13,620 --> 00:25:16,799
you see where where the where the I know

496
00:25:16,799 --> 00:25:19,020
the table is so what am I saying every

497
00:25:19,020 --> 00:25:21,120
directory right

498
00:25:21,120 --> 00:25:23,820
is almost in every directory right why

499
00:25:23,820 --> 00:25:26,900
we need I know table

500
00:25:27,380 --> 00:25:30,360
because because in the directory no

501
00:25:30,360 --> 00:25:32,760
directory in the directory the directory

502
00:25:32,760 --> 00:25:35,580
may have many subdirectories right then

503
00:25:35,580 --> 00:25:37,620
subdirectory may have an in subdirectory

504
00:25:37,620 --> 00:25:40,799
so this directory the I know the data

505
00:25:40,799 --> 00:25:45,120
structure is very big I know this data

506
00:25:45,120 --> 00:25:48,179
structure may be very big

507
00:25:48,179 --> 00:25:50,580
see this is the inode structure if the

508
00:25:50,580 --> 00:25:52,799
fire is Big the inode structure may have

509
00:25:52,799 --> 00:25:54,720
several layers the I know the structure

510
00:25:54,720 --> 00:25:56,340
is very big

511
00:25:56,340 --> 00:25:59,460
then because I know the structure is

512
00:25:59,460 --> 00:26:02,580
very big then we add in another

513
00:26:02,580 --> 00:26:04,980
obstruction on top of the inode

514
00:26:04,980 --> 00:26:07,679
structure we use I know the number this

515
00:26:07,679 --> 00:26:09,600
is a unique number

516
00:26:09,600 --> 00:26:13,380
to represent that the inode

517
00:26:13,380 --> 00:26:15,960
I node the location

518
00:26:15,960 --> 00:26:18,659
so you can think of that

519
00:26:18,659 --> 00:26:20,520
you have a drive lessons right the drive

520
00:26:20,520 --> 00:26:22,320
lessons have your information right but

521
00:26:22,320 --> 00:26:24,620
your drive license has a unique ID right

522
00:26:24,620 --> 00:26:28,620
then then the directory only saved ID

523
00:26:28,620 --> 00:26:31,799
only saved ID they will not save the

524
00:26:31,799 --> 00:26:33,840
whole information will drive lessons the

525
00:26:33,840 --> 00:26:35,880
whole information for the inode that is

526
00:26:35,880 --> 00:26:39,179
the inode table that is I know table so

527
00:26:39,179 --> 00:26:42,840
whenever we look at this this like let's

528
00:26:42,840 --> 00:26:45,480
see well we go we go from the new

529
00:26:45,480 --> 00:26:48,840
directory right the root directory

530
00:26:48,840 --> 00:26:52,440
is the rule directory will

531
00:26:52,440 --> 00:26:55,620
will almost every every file system can

532
00:26:55,620 --> 00:26:58,080
easily locate to the root directly why

533
00:26:58,080 --> 00:27:01,440
the rule directly is directory is is

534
00:27:01,440 --> 00:27:02,760
simply

535
00:27:02,760 --> 00:27:04,260
after

536
00:27:04,260 --> 00:27:06,900
the I know you see here

537
00:27:06,900 --> 00:27:10,580
where's the new directory

538
00:27:15,840 --> 00:27:17,279
check this

539
00:27:17,279 --> 00:27:20,779
see where the loop directory

540
00:27:23,279 --> 00:27:25,200
you see here right it's here the loot

541
00:27:25,200 --> 00:27:26,520
directory is here

542
00:27:26,520 --> 00:27:29,240
so when we when we when we locate any

543
00:27:29,240 --> 00:27:32,159
files we always start from the loot

544
00:27:32,159 --> 00:27:34,260
directory we go to the root directory

545
00:27:34,260 --> 00:27:38,580
and we're looking at the us our usrtc is

546
00:27:38,580 --> 00:27:41,400
a directory we need to find out the I

547
00:27:41,400 --> 00:27:43,200
know the information of this we need to

548
00:27:43,200 --> 00:27:46,020
locate to this I node

549
00:27:46,020 --> 00:27:48,600
we need to look into this I node right

550
00:27:48,600 --> 00:27:52,260
so we locate we see the ID

551
00:27:52,260 --> 00:27:58,080
the load the inode ID of this directory

552
00:27:58,080 --> 00:28:00,600
the subdirectory right user directory

553
00:28:00,600 --> 00:28:05,400
and then we got uh the I know table we

554
00:28:05,400 --> 00:28:07,760
after we find out the ID okay the ID is

555
00:28:07,760 --> 00:28:11,460
6.96 then we can find out the I node we

556
00:28:11,460 --> 00:28:13,740
can find out the I node okay this is the

557
00:28:13,740 --> 00:28:16,919
exactly I node of that I know 6 says

558
00:28:16,919 --> 00:28:19,880
that USR is in the block of

559
00:28:19,880 --> 00:28:25,260
130 to 132 then we find out the block 1

560
00:28:25,260 --> 00:28:28,200
32 we find out the block this is the

561
00:28:28,200 --> 00:28:30,720
physical number we find the block 132

562
00:28:30,720 --> 00:28:33,539
then we can find out the exactly

563
00:28:33,539 --> 00:28:35,279
contents

564
00:28:35,279 --> 00:28:39,179
in the dash USR and Industry since it is

565
00:28:39,179 --> 00:28:42,380
also a directory so it saved it has many

566
00:28:42,380 --> 00:28:45,179
subdirectories right you are not you are

567
00:28:45,179 --> 00:28:47,880
not this USI is not a file it's just a

568
00:28:47,880 --> 00:28:50,640
directory so it means under this it has

569
00:28:50,640 --> 00:28:52,559
many subdirectories and we need to find

570
00:28:52,559 --> 00:28:55,200
out the I know the ID of this directory

571
00:28:55,200 --> 00:28:59,100
which is the AST AST then it has a

572
00:28:59,100 --> 00:29:01,620
unique load you you see this is unique

573
00:29:01,620 --> 00:29:05,700
okay unique AST okay then we look at the

574
00:29:05,700 --> 00:29:09,360
inode 26 we see that I know the 26 then

575
00:29:09,360 --> 00:29:12,480
we find out this here the contents the

576
00:29:12,480 --> 00:29:17,600
real contents of this directory and yes

577
00:29:18,059 --> 00:29:22,220
both the unique ID and the memory

578
00:29:23,279 --> 00:29:26,159
yeah so it's not it's not contains the

579
00:29:26,159 --> 00:29:29,000
memory address but here

580
00:29:29,000 --> 00:29:32,340
the we have the I know the table right

581
00:29:32,340 --> 00:29:34,799
we know the item table is from one to a

582
00:29:34,799 --> 00:29:37,740
very large number right and then there's

583
00:29:37,740 --> 00:29:41,520
a space the other space in the disk and

584
00:29:41,520 --> 00:29:43,799
also in the memory that stores as a

585
00:29:43,799 --> 00:29:44,820
sequence

586
00:29:44,820 --> 00:29:46,860
to save the information so we just need

587
00:29:46,860 --> 00:29:48,659
to search it that is why you use the

588
00:29:48,659 --> 00:29:51,059
inode ID it's from one let's say we only

589
00:29:51,059 --> 00:29:54,000
have 100 different directories and files

590
00:29:54,000 --> 00:29:56,700
right files has a as I know the ID and

591
00:29:56,700 --> 00:29:58,799
also directory also has iron or ID then

592
00:29:58,799 --> 00:30:01,140
you can just after you know the number

593
00:30:01,140 --> 00:30:05,039
then you can point to it it's very easy

594
00:30:05,039 --> 00:30:07,640
it's

595
00:30:07,799 --> 00:30:12,120
then you have 26 right 26 AST then we we

596
00:30:12,120 --> 00:30:15,000
find out the exactly content of the 26

597
00:30:15,000 --> 00:30:17,340
we find out okay this is okay the block

598
00:30:17,340 --> 00:30:24,179
address of this directory is in a 406

599
00:30:24,179 --> 00:30:28,039
then we go to the 406

600
00:30:28,559 --> 00:30:30,840
we see

601
00:30:30,840 --> 00:30:34,200
this the inode right the inode I node

602
00:30:34,200 --> 00:30:37,260
number of the this file this file is

603
00:30:37,260 --> 00:30:39,720
Mbox right that is I know number is 16

604
00:30:39,720 --> 00:30:41,820
right there's a one step left

605
00:30:41,820 --> 00:30:45,120
it needs to look at the 16th where the

606
00:30:45,120 --> 00:30:47,340
16th I know the information and after

607
00:30:47,340 --> 00:30:49,020
you look at that I know the information

608
00:30:49,020 --> 00:30:51,720
of the 16 you can find out where exactly

609
00:30:51,720 --> 00:30:54,179
this file is

610
00:30:54,179 --> 00:30:55,740
uh

611
00:30:55,740 --> 00:30:59,059
it's a little tricky

612
00:30:59,700 --> 00:31:02,520
so so I noticed that I know the ID is

613
00:31:02,520 --> 00:31:05,399
just one step before you find inode you

614
00:31:05,399 --> 00:31:06,720
do not because

615
00:31:06,720 --> 00:31:09,600
we cannot deal we we need to blame the I

616
00:31:09,600 --> 00:31:12,000
know the right a file has I know that

617
00:31:12,000 --> 00:31:13,860
you need to have a way to name the I

618
00:31:13,860 --> 00:31:16,020
know that is why we use the inode ID is

619
00:31:16,020 --> 00:31:18,419
it's just a unique number you can limit

620
00:31:18,419 --> 00:31:22,080
to in any files or directories

621
00:31:22,080 --> 00:31:24,840
and then and then we save the inode in

622
00:31:24,840 --> 00:31:27,120
one place in one place in memory why we

623
00:31:27,120 --> 00:31:28,980
need to save it in the disk also in the

624
00:31:28,980 --> 00:31:31,260
memory that is because you are not going

625
00:31:31,260 --> 00:31:33,779
to open all the files at the same time

626
00:31:33,779 --> 00:31:36,600
so most so all I know the information

627
00:31:36,600 --> 00:31:40,380
are in the disk but the active files I

628
00:31:40,380 --> 00:31:42,480
node are in the memory

629
00:31:42,480 --> 00:31:44,279
active files

630
00:31:44,279 --> 00:31:47,220
I know in the memory okay so this is the

631
00:31:47,220 --> 00:31:49,679
file system chapter the review of this

632
00:31:49,679 --> 00:31:51,919
chapter

633
00:32:04,380 --> 00:32:06,659
so let's learn another file system that

634
00:32:06,659 --> 00:32:09,000
is a distributed file system is one part

635
00:32:09,000 --> 00:32:13,039
of our OS Hot Topics okay

636
00:32:13,380 --> 00:32:15,779
so before we go to the distributed file

637
00:32:15,779 --> 00:32:20,340
system we need to we need to uh

638
00:32:20,340 --> 00:32:23,760
C have some background information

639
00:32:23,760 --> 00:32:27,200
okay ah

640
00:32:27,419 --> 00:32:30,779
Big Data why I'm talking Big Data before

641
00:32:30,779 --> 00:32:32,279
the distributed file system because

642
00:32:32,279 --> 00:32:35,000
emojis

643
00:32:42,240 --> 00:32:44,580
sometimes

644
00:32:44,580 --> 00:32:47,340
the data like a lot of data yeah we need

645
00:32:47,340 --> 00:32:50,299
a we need

646
00:32:50,760 --> 00:32:52,260
yeah yeah

647
00:32:52,260 --> 00:32:54,240
yeah

648
00:32:54,240 --> 00:32:57,600
yeah so big data is is a trend it's very

649
00:32:57,600 --> 00:33:00,899
important right now right so why why we

650
00:33:00,899 --> 00:33:03,360
need to talk about Big Data because the

651
00:33:03,360 --> 00:33:06,480
because this there's a lot of data right

652
00:33:06,480 --> 00:33:09,659
and you cannot save it in one file

653
00:33:09,659 --> 00:33:12,720
system locally we need many

654
00:33:12,720 --> 00:33:15,419
machines together to constitute a

655
00:33:15,419 --> 00:33:18,840
distributed file system so what it means

656
00:33:18,840 --> 00:33:20,340
by Distributing the file system

657
00:33:20,340 --> 00:33:22,380
distributed file system

658
00:33:22,380 --> 00:33:25,940
simply makes it simply guessing it okay

659
00:33:25,940 --> 00:33:29,760
one computer is not enough we add in 10

660
00:33:29,760 --> 00:33:31,919
thousands of computers together and

661
00:33:31,919 --> 00:33:34,440
Aggregates their spaces making them look

662
00:33:34,440 --> 00:33:37,500
like a one file system then that file

663
00:33:37,500 --> 00:33:39,539
system is called distributed file system

664
00:33:39,539 --> 00:33:41,940
why to call distributed file system

665
00:33:41,940 --> 00:33:45,899
because it is consists of not only one

666
00:33:45,899 --> 00:33:48,240
machine that consists of 10 thousands of

667
00:33:48,240 --> 00:33:51,299
machines and they are logically sorry

668
00:33:51,299 --> 00:33:54,059
they are physically distributed that is

669
00:33:54,059 --> 00:33:56,159
why it's called distributed file system

670
00:33:56,159 --> 00:33:59,460
okay and then what is Big Data so big

671
00:33:59,460 --> 00:34:02,600
data is oh okay this is

672
00:34:02,600 --> 00:34:06,000
that is very big okay it's not that

673
00:34:06,000 --> 00:34:07,320
complex

674
00:34:07,320 --> 00:34:11,280
is very big a lot of formats and complex

675
00:34:11,280 --> 00:34:14,639
okay large amounts so how big did you

676
00:34:14,639 --> 00:34:17,418
speak or how big do you speak

677
00:34:17,418 --> 00:34:22,098
these are all the data we have more data

678
00:34:24,719 --> 00:34:27,480
so we are looking at the databytes

679
00:34:27,480 --> 00:34:30,719
your habites of scale how big it is big

680
00:34:30,719 --> 00:34:33,418
okay and it's almost increasing like it

681
00:34:33,418 --> 00:34:36,899
is portion only it's increasing very big

682
00:34:36,899 --> 00:34:39,239
so who is generating Big Data everyone

683
00:34:39,239 --> 00:34:41,940
every one of you is generating Big Data

684
00:34:41,940 --> 00:34:44,639
you may not notice wherever you are

685
00:34:44,639 --> 00:34:46,739
using your cell phone your activities

686
00:34:46,739 --> 00:34:49,280
are going to be locked by the back end

687
00:34:49,280 --> 00:34:52,199
whenever you are purchasing an item in

688
00:34:52,199 --> 00:34:55,440
the Amazon Amazon get all of your

689
00:34:55,440 --> 00:34:57,420
information what you like what you do

690
00:34:57,420 --> 00:34:59,820
not like what you are going to purchase

691
00:34:59,820 --> 00:35:01,080
together

692
00:35:01,080 --> 00:35:03,420
what kind of persons you are for example

693
00:35:03,420 --> 00:35:06,000
if you always purchase the cheap items

694
00:35:06,000 --> 00:35:08,700
they will not think that you are

695
00:35:08,700 --> 00:35:11,460
rich person then when they give you the

696
00:35:11,460 --> 00:35:13,140
recommendations you will not receive

697
00:35:13,140 --> 00:35:16,099
some recommendations like

698
00:35:16,099 --> 00:35:19,140
expensive item you may receive the item

699
00:35:19,140 --> 00:35:23,339
that is in your range okay in the in

700
00:35:23,339 --> 00:35:25,579
your intense range that is

701
00:35:25,579 --> 00:35:28,700
there's a lot of study about that

702
00:35:28,700 --> 00:35:31,380
I did some research about that it's like

703
00:35:31,380 --> 00:35:33,380
now in my stream processing system

704
00:35:33,380 --> 00:35:36,180
research part of my research okay it's

705
00:35:36,180 --> 00:35:37,680
very interesting

706
00:35:37,680 --> 00:35:38,900
um

707
00:35:38,900 --> 00:35:42,599
you you you'll never realize how this

708
00:35:42,599 --> 00:35:44,820
big these companies capturing your

709
00:35:44,820 --> 00:35:47,640
activity what makes all your activities

710
00:35:47,640 --> 00:35:52,200
are going to be analyzed and they have

711
00:35:52,200 --> 00:35:55,020
they have many processes at the back end

712
00:35:55,020 --> 00:35:58,800
to analyze your behavior

713
00:35:58,800 --> 00:36:00,900
so there's a lot of big data we need to

714
00:36:00,900 --> 00:36:04,260
find a way to save this big data we need

715
00:36:04,260 --> 00:36:06,780
to find a way to save this big data so

716
00:36:06,780 --> 00:36:08,339
before we're talking about the way that

717
00:36:08,339 --> 00:36:10,020
we save this big data let's talking

718
00:36:10,020 --> 00:36:12,420
about the way that we process this big

719
00:36:12,420 --> 00:36:15,300
data okay so I'm going to introduce you

720
00:36:15,300 --> 00:36:17,280
a very classic

721
00:36:17,280 --> 00:36:19,980
model that we process the big data is

722
00:36:19,980 --> 00:36:21,780
called the mapreduce model you already

723
00:36:21,780 --> 00:36:23,640
know that of course your project 2 is

724
00:36:23,640 --> 00:36:25,859
about it

725
00:36:25,859 --> 00:36:28,320
I hope you like it because it will be

726
00:36:28,320 --> 00:36:31,200
very useful USB as major students if if

727
00:36:31,200 --> 00:36:33,900
you graduate and people ask you what is

728
00:36:33,900 --> 00:36:35,579
examples you do not know then you should

729
00:36:35,579 --> 00:36:37,740
be ashamed of all that because it's a

730
00:36:37,740 --> 00:36:40,320
very classic yahoo first developed that

731
00:36:40,320 --> 00:36:43,260
and then Google has been used for many

732
00:36:43,260 --> 00:36:46,260
years but they recently there are of

733
00:36:46,260 --> 00:36:47,660
some Modern

734
00:36:47,660 --> 00:36:49,520
architecture

735
00:36:49,520 --> 00:36:52,440
and disregard mapreduce however it's

736
00:36:52,440 --> 00:36:54,839
very classic so what is the map reduce

737
00:36:54,839 --> 00:36:57,300
mapreduce means that if you have a big

738
00:36:57,300 --> 00:37:00,660
thing if you have a big task you cannot

739
00:37:00,660 --> 00:37:02,520
finish the buy one

740
00:37:02,520 --> 00:37:04,980
one computer one person if you cannot

741
00:37:04,980 --> 00:37:06,900
finish the by a

742
00:37:06,900 --> 00:37:10,020
one let's say super computer then why

743
00:37:10,020 --> 00:37:12,540
not you just divide this work

744
00:37:12,540 --> 00:37:15,800
into many small parts and ask

745
00:37:15,800 --> 00:37:19,140
some more motions to finish it

746
00:37:19,140 --> 00:37:22,380
for you and then later you as the master

747
00:37:22,380 --> 00:37:24,359
you just need to aggregate the results

748
00:37:24,359 --> 00:37:26,880
so that is the divide and conquer

749
00:37:26,880 --> 00:37:30,119
concept we divide the work and then we

750
00:37:30,119 --> 00:37:32,880
combine the results then the good thing

751
00:37:32,880 --> 00:37:35,640
about this approach is that it is very

752
00:37:35,640 --> 00:37:38,820
very scalable why it is very scalable

753
00:37:38,820 --> 00:37:41,220
where is the bottleneck the bottom lock

754
00:37:41,220 --> 00:37:44,160
is owning in the master right the master

755
00:37:44,160 --> 00:37:47,780
is doing the dividing the work

756
00:37:52,800 --> 00:37:55,880
give me one second

757
00:37:57,660 --> 00:38:00,660
foreign

758
00:38:20,480 --> 00:38:23,400
like I need to divide the work for

759
00:38:23,400 --> 00:38:25,560
example I have if I have right now I

760
00:38:25,560 --> 00:38:28,680
have 100 students so I prepare 100 exam

761
00:38:28,680 --> 00:38:30,780
papers I gave it to you you guys finish

762
00:38:30,780 --> 00:38:33,599
it and then I aggregate the results I

763
00:38:33,599 --> 00:38:35,220
come back I get the results all the

764
00:38:35,220 --> 00:38:38,040
results but if I have 1 000 students I

765
00:38:38,040 --> 00:38:39,599
will do the same thing I will prepare

766
00:38:39,599 --> 00:38:42,720
1000 papers and then distribute it and

767
00:38:42,720 --> 00:38:45,060
then I come I combine the results if I

768
00:38:45,060 --> 00:38:47,099
have 10 000 students I'm also doing the

769
00:38:47,099 --> 00:38:48,960
same thing so I'm the only important

770
00:38:48,960 --> 00:38:50,640
like the master doing the Divide work

771
00:38:50,640 --> 00:38:52,980
and combined results is only important

772
00:38:52,980 --> 00:38:56,820
so if it is a super it's if it is a

773
00:38:56,820 --> 00:38:58,980
difficult thing then I can divide it

774
00:38:58,980 --> 00:39:01,079
into many many small parts and then

775
00:39:01,079 --> 00:39:04,440
divide it and hire many workers as many

776
00:39:04,440 --> 00:39:07,800
as I want to help me finish it so it is

777
00:39:07,800 --> 00:39:10,579
very scalable

778
00:39:11,280 --> 00:39:12,839
hey

779
00:39:12,839 --> 00:39:15,720
pardon distributed processing so this is

780
00:39:15,720 --> 00:39:17,400
called distributed processing this

781
00:39:17,400 --> 00:39:19,260
processing is long tuber it's

782
00:39:19,260 --> 00:39:22,619
non-trivial why it is lounge River well

783
00:39:22,619 --> 00:39:25,320
like you guys okay some of you are very

784
00:39:25,320 --> 00:39:28,619
hard hard working like this course some

785
00:39:28,619 --> 00:39:30,060
of you may

786
00:39:30,060 --> 00:39:32,640
like the other course and do not want to

787
00:39:32,640 --> 00:39:35,400
devote your time into that course so

788
00:39:35,400 --> 00:39:38,579
let's say some are very productive some

789
00:39:38,579 --> 00:39:41,880
are not productive right

790
00:39:41,880 --> 00:39:45,599
and some even quit this course right

791
00:39:45,599 --> 00:39:48,180
some fails like what happens if the task

792
00:39:48,180 --> 00:39:50,700
fails how to assign to different workers

793
00:39:50,700 --> 00:39:52,980
in an efficient way how do workers

794
00:39:52,980 --> 00:39:54,599
exchange the results

795
00:39:54,599 --> 00:39:58,400
why they need to exchange the results

796
00:39:58,680 --> 00:40:01,380
if it is a graph let's say it's a graph

797
00:40:01,380 --> 00:40:03,359
processing work I do not know if you are

798
00:40:03,359 --> 00:40:05,400
you you have done anything about the

799
00:40:05,400 --> 00:40:07,260
graph in the graph algorithms there's

800
00:40:07,260 --> 00:40:09,839
algorithms called like we calculating

801
00:40:09,839 --> 00:40:11,940
the page rank right we're calculating

802
00:40:11,940 --> 00:40:14,460
the page Rank and we're covering the

803
00:40:14,460 --> 00:40:16,980
page rank calculating the shortest path

804
00:40:16,980 --> 00:40:18,780
shortest pass we calculating the

805
00:40:18,780 --> 00:40:20,820
connected components

806
00:40:20,820 --> 00:40:24,000
in the graph for this graph

807
00:40:24,000 --> 00:40:28,560
work big graph work like in Facebook

808
00:40:28,560 --> 00:40:32,040
has a super huge graph of the social

809
00:40:32,040 --> 00:40:35,339
media like I'm the friends of another

810
00:40:35,339 --> 00:40:38,579
person so the graph is huge is graph is

811
00:40:38,579 --> 00:40:41,700
huge then when I divided the graphs I

812
00:40:41,700 --> 00:40:44,040
made divided into a wrong way and the

813
00:40:44,040 --> 00:40:46,140
only workers need to exchange the

814
00:40:46,140 --> 00:40:47,099
results

815
00:40:47,099 --> 00:40:50,280
the exchangeable results between sure

816
00:40:50,280 --> 00:40:54,300
and accurate accurate

817
00:40:54,300 --> 00:40:57,420
outputs so how do workers exchange the

818
00:40:57,420 --> 00:40:59,640
result how to synchronize distributed

819
00:40:59,640 --> 00:41:01,800
worker allocates to different workers

820
00:41:01,800 --> 00:41:04,500
well I'm asking I'm asking these

821
00:41:04,500 --> 00:41:06,960
questions to you you can you creatively

822
00:41:06,960 --> 00:41:09,780
answer this how to assign the task code

823
00:41:09,780 --> 00:41:13,700
to different workers in an efficient way

824
00:41:15,000 --> 00:41:17,480
yes

825
00:41:27,020 --> 00:41:29,760
if you have to say a number for how like

826
00:41:29,760 --> 00:41:32,160
good they are at the job and

827
00:41:32,160 --> 00:41:35,339
track of how available they are then you

828
00:41:35,339 --> 00:41:37,079
know that you know what worker you want

829
00:41:37,079 --> 00:41:38,220
to assign away

830
00:41:38,220 --> 00:41:40,440
okay okay they're very good very good

831
00:41:40,440 --> 00:41:42,359
but but the challenge I will give you

832
00:41:42,359 --> 00:41:45,180
another chance the challenging is that

833
00:41:45,180 --> 00:41:48,480
I I worry about the beginning I know

834
00:41:48,480 --> 00:41:50,400
nothing about these workers I do not

835
00:41:50,400 --> 00:41:53,540
know how good they are

836
00:41:53,880 --> 00:41:57,560
you cannot guess you can just like

837
00:41:57,560 --> 00:42:00,780
sync them as the same right that is why

838
00:42:00,780 --> 00:42:02,940
we have when we're setting a system we

839
00:42:02,940 --> 00:42:05,099
give the default settings

840
00:42:05,099 --> 00:42:06,480
pardon

841
00:42:06,480 --> 00:42:09,680
how are you going to yeah

842
00:42:16,339 --> 00:42:19,020
yeah very good very good this is how to

843
00:42:19,020 --> 00:42:20,820
see some video I'll show you I will tell

844
00:42:20,820 --> 00:42:22,740
you a lot of balances why load balancer

845
00:42:22,740 --> 00:42:24,599
has a low balance to keep monitoring it

846
00:42:24,599 --> 00:42:27,000
like first we will not have a low

847
00:42:27,000 --> 00:42:28,920
balance to keep monitoring we will have

848
00:42:28,920 --> 00:42:31,440
a separate monitor sometimes we use the

849
00:42:31,440 --> 00:42:34,800
software called Zone keeper to do that

850
00:42:34,800 --> 00:42:37,020
um you are used to actually if you

851
00:42:37,020 --> 00:42:38,760
become a software engineering because

852
00:42:38,760 --> 00:42:41,460
almost all the Distributors see some

853
00:42:41,460 --> 00:42:43,260
companies use that software so we have

854
00:42:43,260 --> 00:42:45,000
let's say we have a Monitor to Monitor

855
00:42:45,000 --> 00:42:47,220
in their progress and we found out a

856
00:42:47,220 --> 00:42:49,260
worker is very slow we call it a

857
00:42:49,260 --> 00:42:51,839
struggler than what we did we are going

858
00:42:51,839 --> 00:42:53,640
to do what we are going to we are going

859
00:42:53,640 --> 00:42:55,740
to hire another worker to do the same

860
00:42:55,740 --> 00:42:59,280
work and then after we found out that he

861
00:42:59,280 --> 00:43:03,119
did faster than the slower one we do a

862
00:43:03,119 --> 00:43:04,500
quick replace

863
00:43:04,500 --> 00:43:07,680
that is how the mapreduce system did

864
00:43:07,680 --> 00:43:09,960
okay

865
00:43:09,960 --> 00:43:13,020
so what happens if the task fail any

866
00:43:13,020 --> 00:43:15,599
students have a

867
00:43:15,599 --> 00:43:18,119
so for example if therefore I I have a

868
00:43:18,119 --> 00:43:21,540
100 let's see here I have I have

869
00:43:21,540 --> 00:43:24,300
hear the thing okay I have 10 gigabytes

870
00:43:24,300 --> 00:43:28,560
of the word content word office like

871
00:43:28,560 --> 00:43:31,619
um how to say that like documents 10

872
00:43:31,619 --> 00:43:34,440
gigabytes of documents it's like 10

873
00:43:34,440 --> 00:43:37,079
thousands of files I need to you guys to

874
00:43:37,079 --> 00:43:39,839
try and convert it for me to convert it

875
00:43:39,839 --> 00:43:41,700
from the world contents to the PDF

876
00:43:41,700 --> 00:43:44,339
contents so I'm what I'm going to do is

877
00:43:44,339 --> 00:43:46,560
that I have this 100 students right you

878
00:43:46,560 --> 00:43:49,619
are all my workers so I divide my

879
00:43:49,619 --> 00:43:51,440
documents

880
00:43:51,440 --> 00:43:55,859
evenly in 100 parts and I find each of

881
00:43:55,859 --> 00:43:57,660
you

882
00:43:57,660 --> 00:44:01,500
like like turns out like one

883
00:44:01,500 --> 00:44:03,900
ten thousand like one thousand okay each

884
00:44:03,900 --> 00:44:06,599
of you got one thousand ten thousand one

885
00:44:06,599 --> 00:44:08,339
hundred if I have one hundred thousand

886
00:44:08,339 --> 00:44:11,099
of files okay and then each of you got

887
00:44:11,099 --> 00:44:13,980
one thousand files you guys try and

888
00:44:13,980 --> 00:44:17,040
convert this file from the document the

889
00:44:17,040 --> 00:44:19,980
word format to the PDF format and give

890
00:44:19,980 --> 00:44:22,920
me back give me back tomorrow okay what

891
00:44:22,920 --> 00:44:25,859
if one of you guys

892
00:44:25,859 --> 00:44:29,160
half of some emergency so you cannot do

893
00:44:29,160 --> 00:44:30,359
this work

894
00:44:30,359 --> 00:44:33,180
how can I ensure that I got in love for

895
00:44:33,180 --> 00:44:35,280
I got the order

896
00:44:35,280 --> 00:44:38,220
files for all the formatted files like

897
00:44:38,220 --> 00:44:40,319
the PDF files

898
00:44:40,319 --> 00:44:43,619
I have 100 000 files it then I divided

899
00:44:43,619 --> 00:44:46,619
it to you each of you have one thousand

900
00:44:46,619 --> 00:44:48,119
but

901
00:44:48,119 --> 00:44:50,160
it's possible like some emergency

902
00:44:50,160 --> 00:44:52,980
happens some students cannot finish this

903
00:44:52,980 --> 00:44:54,119
work

904
00:44:54,119 --> 00:44:57,260
and the guy yes

905
00:44:58,800 --> 00:45:01,440
very good that is the that is what we do

906
00:45:01,440 --> 00:45:02,760
okay we are going to learn that later

907
00:45:02,760 --> 00:45:04,260
how we did that but you have an

908
00:45:04,260 --> 00:45:06,720
intuition first

909
00:45:06,720 --> 00:45:09,119
while the task fail what is tough fair

910
00:45:09,119 --> 00:45:12,119
then I have backup instead of give each

911
00:45:12,119 --> 00:45:17,099
one of you 1000 I give each one of you

912
00:45:17,099 --> 00:45:19,020
three thousand

913
00:45:19,020 --> 00:45:21,599
so you cover another two students each

914
00:45:21,599 --> 00:45:24,540
of you can cover any random two students

915
00:45:24,540 --> 00:45:26,940
then the chance is that

916
00:45:26,940 --> 00:45:30,960
I can I can tolerate multiple failures

917
00:45:30,960 --> 00:45:33,240
right I can talk because whenever a

918
00:45:33,240 --> 00:45:37,220
failure I want a student fails

919
00:45:39,500 --> 00:45:43,380
another two students that contains her

920
00:45:43,380 --> 00:45:46,920
or his work that is called replicate

921
00:45:46,920 --> 00:45:48,780
replication

922
00:45:48,780 --> 00:45:51,300
how to singularize distributed tasks

923
00:45:51,300 --> 00:45:52,740
located to different workers of

924
00:45:52,740 --> 00:45:54,960
synchronize the same thing how we handle

925
00:45:54,960 --> 00:45:56,760
the strugglers like how synchronize

926
00:45:56,760 --> 00:45:59,160
their progress synchronize their

927
00:45:59,160 --> 00:46:02,040
progress how we synchronize that we

928
00:46:02,040 --> 00:46:03,180
learn it

929
00:46:03,180 --> 00:46:06,560
how we synchronize that

930
00:46:06,960 --> 00:46:08,940
synchronize

931
00:46:08,940 --> 00:46:11,599
yeah array

932
00:46:11,599 --> 00:46:14,400
so that is for the camp process

933
00:46:14,400 --> 00:46:15,900
communication

934
00:46:15,900 --> 00:46:18,480
but we learned that in that chapter we

935
00:46:18,480 --> 00:46:21,300
set a barrier right when we do

936
00:46:21,300 --> 00:46:23,220
synchronization it's always the concept

937
00:46:23,220 --> 00:46:26,160
of barrier

938
00:46:26,160 --> 00:46:29,160
b-a-r-r-i-e-r

939
00:46:30,119 --> 00:46:34,800
remember this burial we saw

940
00:46:34,800 --> 00:46:39,079
so let's look at how we did that okay

941
00:46:39,599 --> 00:46:42,240
so big data storage is challenging it's

942
00:46:42,240 --> 00:46:46,079
challenging okay we have huge size of

943
00:46:46,079 --> 00:46:48,240
data

944
00:46:48,240 --> 00:46:51,119
reliability of storing this data is

945
00:46:51,119 --> 00:46:54,119
challenging all kinds of failures of

946
00:46:54,119 --> 00:46:56,099
this failure Hardware failure Network

947
00:46:56,099 --> 00:46:58,619
failure all kinds of failures

948
00:46:58,619 --> 00:47:01,880
probability of failures simply increase

949
00:47:01,880 --> 00:47:06,079
with the number of motions

950
00:47:07,740 --> 00:47:09,780
so there's some more motions more fails

951
00:47:09,780 --> 00:47:10,619
okay

952
00:47:10,619 --> 00:47:13,619
that's very easy to understand so

953
00:47:13,619 --> 00:47:17,220
well then so it's hard to say that so

954
00:47:17,220 --> 00:47:20,819
a lot huge size of a lot of data a lot

955
00:47:20,819 --> 00:47:23,819
of data and a lot of failures a lot of

956
00:47:23,819 --> 00:47:28,020
failures okay so here's the solution

957
00:47:28,020 --> 00:47:30,200
foreign

958
00:47:35,180 --> 00:47:37,859
of the distributor file system it's like

959
00:47:37,859 --> 00:47:39,780
we say the

960
00:47:39,780 --> 00:47:42,119
when we talk when we

961
00:47:42,119 --> 00:47:44,579
um file system is just one part of the

962
00:47:44,579 --> 00:47:46,680
file system right here one type of file

963
00:47:46,680 --> 00:47:49,319
signal Hadoop is just the one product of

964
00:47:49,319 --> 00:47:51,599
the distributed file systems so any

965
00:47:51,599 --> 00:47:53,520
students

966
00:47:53,520 --> 00:47:56,220
heard of Hadoop

967
00:47:56,220 --> 00:47:59,220
Hadoop

968
00:48:02,940 --> 00:48:06,060
what Hadoop offers is offered as offers

969
00:48:06,060 --> 00:48:07,800
okay it's

970
00:48:07,800 --> 00:48:09,800
um

971
00:48:10,260 --> 00:48:12,599
so Hadoop

972
00:48:12,599 --> 00:48:14,460
so before we're talking about the Hadoop

973
00:48:14,460 --> 00:48:15,660
with like

974
00:48:15,660 --> 00:48:18,540
um you know the map reduce mapreduce is

975
00:48:18,540 --> 00:48:20,339
very successful might produce

976
00:48:20,339 --> 00:48:22,200
computation model is very successful

977
00:48:22,200 --> 00:48:24,420
right we already know how successful it

978
00:48:24,420 --> 00:48:27,540
is but the interesting thing I want to

979
00:48:27,540 --> 00:48:29,280
tell you a story about that one member

980
00:48:29,280 --> 00:48:31,260
use is further developed and the

981
00:48:31,260 --> 00:48:33,300
researcher researchers feel very excited

982
00:48:33,300 --> 00:48:36,359
he feels that his computation model is

983
00:48:36,359 --> 00:48:38,280
super smart so he wrote a paper about

984
00:48:38,280 --> 00:48:41,339
that and he submitted to a

985
00:48:41,339 --> 00:48:43,920
like very famous conference and then the

986
00:48:43,920 --> 00:48:45,540
conference rejects that

987
00:48:45,540 --> 00:48:48,780
so like reject it and he submitted like

988
00:48:48,780 --> 00:48:50,940
several times but it all got rejected

989
00:48:50,940 --> 00:48:52,680
then he in

990
00:48:52,680 --> 00:48:53,880
he

991
00:48:53,880 --> 00:48:56,220
but then he

992
00:48:56,220 --> 00:48:58,319
like I think he submitted to a

993
00:48:58,319 --> 00:49:00,720
not-famous place and then finally got

994
00:49:00,720 --> 00:49:03,960
accepted but he does not have no idea

995
00:49:03,960 --> 00:49:06,660
how successful the mapreduce model would

996
00:49:06,660 --> 00:49:09,660
be like my produced in a page rank or

997
00:49:09,660 --> 00:49:12,300
all these models okay this is a very

998
00:49:12,300 --> 00:49:14,099
interesting story and same as the Yahoo

999
00:49:14,099 --> 00:49:18,800
so Yahoo Yahoo later sell this the

1000
00:49:18,800 --> 00:49:21,000
distributor file system to Google so

1001
00:49:21,000 --> 00:49:23,160
Google has been using for very long time

1002
00:49:23,160 --> 00:49:26,160
and then Google developed the big table

1003
00:49:26,160 --> 00:49:29,040
you may heard of that it's called it's

1004
00:49:29,040 --> 00:49:30,180
um

1005
00:49:30,180 --> 00:49:33,660
it is also part of the Hadoop the Hadoop

1006
00:49:33,660 --> 00:49:36,119
project okay so let's talk about see how

1007
00:49:36,119 --> 00:49:38,160
what had with Hadoop means Hadoop

1008
00:49:38,160 --> 00:49:41,220
distributed file system so DFS so before

1009
00:49:41,220 --> 00:49:43,740
we talk about DFS any students heard of

1010
00:49:43,740 --> 00:49:46,460
NFS

1011
00:49:46,740 --> 00:49:49,560
unfs

1012
00:49:49,560 --> 00:49:53,280
what is on FS you should know that

1013
00:49:53,280 --> 00:49:54,619
all right

1014
00:49:54,619 --> 00:49:56,640
working class

1015
00:49:56,640 --> 00:49:58,579
even myself

1016
00:49:58,579 --> 00:50:01,079
this Samurai

1017
00:50:01,079 --> 00:50:02,760
no

1018
00:50:02,760 --> 00:50:04,800
no network file system you you use

1019
00:50:04,800 --> 00:50:06,660
dropbox right

1020
00:50:06,660 --> 00:50:09,000
Dropbox is uh

1021
00:50:09,000 --> 00:50:12,060
very very later version of the NFS

1022
00:50:12,060 --> 00:50:16,140
Network file system right so hdfs Hadoop

1023
00:50:16,140 --> 00:50:19,760
distributed file system okay

1024
00:50:20,359 --> 00:50:24,000
what Hadoop let's see what Hadoop offers

1025
00:50:24,000 --> 00:50:26,599
is that

1026
00:50:26,700 --> 00:50:31,079
is offers a very reliable reliable this

1027
00:50:31,079 --> 00:50:33,240
is the keywords okay how do what Hadoop

1028
00:50:33,240 --> 00:50:36,000
offers is that reliable for torrent file

1029
00:50:36,000 --> 00:50:38,819
system reliable for torrents file system

1030
00:50:38,819 --> 00:50:42,000
to store a huge amount of Big Data huge

1031
00:50:42,000 --> 00:50:45,540
amount of big data so every file system

1032
00:50:45,540 --> 00:50:48,619
they have a system go into the

1033
00:50:48,619 --> 00:50:52,680
hdfs heat system goal is her system goal

1034
00:50:52,680 --> 00:50:55,920
is for tolerance for tolerance then as a

1035
00:50:55,920 --> 00:50:58,020
programmer you no longer need to worry

1036
00:50:58,020 --> 00:51:01,319
about where the file is located

1037
00:51:01,319 --> 00:51:04,559
how to handle failures and data loss how

1038
00:51:04,559 --> 00:51:07,140
to divide the computation how to program

1039
00:51:07,140 --> 00:51:09,359
for scaling

1040
00:51:09,359 --> 00:51:11,599
foreign

1041
00:51:14,520 --> 00:51:17,700
so this is a real word example that use

1042
00:51:17,700 --> 00:51:20,640
heart use Hadoop file systems Hadoop

1043
00:51:20,640 --> 00:51:22,680
file systems is the file system that

1044
00:51:22,680 --> 00:51:25,980
supports mapreduce okay so the goal the

1045
00:51:25,980 --> 00:51:27,780
make the entire

1046
00:51:27,780 --> 00:51:31,260
let's say we have okay we have this

1047
00:51:31,260 --> 00:51:34,319
articles we need to translate this into

1048
00:51:34,319 --> 00:51:36,780
the PDF we need to translate this into

1049
00:51:36,780 --> 00:51:40,440
the PDF so our solution our solution is

1050
00:51:40,440 --> 00:51:43,280
using the

1051
00:51:43,500 --> 00:51:46,980
Amazon ec2 servers and a simple storage

1052
00:51:46,980 --> 00:51:50,280
systems so it translates four terabytes

1053
00:51:50,280 --> 00:51:54,960
of images to PDF files okay okay so

1054
00:51:54,960 --> 00:51:58,559
how much time and how much cost

1055
00:51:58,559 --> 00:52:02,040
if if if it is owned by you you need to

1056
00:52:02,040 --> 00:52:04,319
do that think of that do it in your

1057
00:52:04,319 --> 00:52:07,319
laptop how much time it will take and

1058
00:52:07,319 --> 00:52:10,260
how much cost it will you will have

1059
00:52:10,260 --> 00:52:14,880
or if you we put the Amazon ec2 servers

1060
00:52:14,880 --> 00:52:17,819
in a simple storage system like S3

1061
00:52:17,819 --> 00:52:20,720
we only need 24 hours and of course is

1062
00:52:20,720 --> 00:52:25,500
240 dollars okay 240 dollars

1063
00:52:25,500 --> 00:52:28,079
seeing the other slides about that the

1064
00:52:28,079 --> 00:52:31,520
the original cost

1065
00:52:34,260 --> 00:52:36,359
star slide there's an original course

1066
00:52:36,359 --> 00:52:38,460
okay there's the original code so it's

1067
00:52:38,460 --> 00:52:39,960
super high

1068
00:52:39,960 --> 00:52:41,819
so we are happy okay

1069
00:52:41,819 --> 00:52:45,260
so this is a little story about Hadoop

1070
00:52:45,260 --> 00:52:47,700
so it's Hadoop is open source

1071
00:52:47,700 --> 00:52:49,619
implementation based on Google file

1072
00:52:49,619 --> 00:52:53,339
system and mapreduce from Google

1073
00:52:53,339 --> 00:52:55,619
I was created by

1074
00:52:55,619 --> 00:52:59,480
them in the related to

1075
00:52:59,480 --> 00:53:02,599
Apache in

1076
00:53:03,000 --> 00:53:06,300
2006 so this is a Hadoop slack Hadoop

1077
00:53:06,300 --> 00:53:09,000
slack uh

1078
00:53:09,000 --> 00:53:12,180
so had to this is the Hadoop hdfs okay

1079
00:53:12,180 --> 00:53:15,720
Hadoop this hdfs and then my producer is

1080
00:53:15,720 --> 00:53:19,740
working on top of it Peak hive

1081
00:53:19,740 --> 00:53:20,819
because

1082
00:53:20,819 --> 00:53:24,119
Central and Edge base you can think of

1083
00:53:24,119 --> 00:53:27,000
that they are just a

1084
00:53:27,000 --> 00:53:29,640
more beautiful libraries or interfaces

1085
00:53:29,640 --> 00:53:32,960
of mapreduce

1086
00:53:33,059 --> 00:53:35,400
they are more user-friendly they are

1087
00:53:35,400 --> 00:53:37,440
more user-friendly so in the map reduce

1088
00:53:37,440 --> 00:53:40,260
if you play with the software well we

1089
00:53:40,260 --> 00:53:42,599
need to we need to roll the map code and

1090
00:53:42,599 --> 00:53:45,359
the reduce code in Java right and then

1091
00:53:45,359 --> 00:53:48,119
we combine it and then run it it's not a

1092
00:53:48,119 --> 00:53:51,180
user friend frequently user

1093
00:53:51,180 --> 00:53:53,640
friendly because if you are not a system

1094
00:53:53,640 --> 00:53:56,040
programmer you do not load code you know

1095
00:53:56,040 --> 00:53:58,140
nothing about coding you may find out

1096
00:53:58,140 --> 00:54:00,420
it's very hard to use mapreduce that is

1097
00:54:00,420 --> 00:54:04,260
why this other software developed so for

1098
00:54:04,260 --> 00:54:07,619
using if you're using this software you

1099
00:54:07,619 --> 00:54:09,359
do not need to write a code you do not

1100
00:54:09,359 --> 00:54:11,220
need to write a mapreduce code you just

1101
00:54:11,220 --> 00:54:12,380
need to

1102
00:54:12,380 --> 00:54:14,400
familiar with their

1103
00:54:14,400 --> 00:54:16,740
their command you just need to familiar

1104
00:54:16,740 --> 00:54:18,300
with their comments then you can know

1105
00:54:18,300 --> 00:54:20,819
how to use it

1106
00:54:20,819 --> 00:54:23,700
so today we are going to discuss how the

1107
00:54:23,700 --> 00:54:27,599
hdfs is developed okay so so there are

1108
00:54:27,599 --> 00:54:30,660
some hdfs resources certain unless

1109
00:54:30,660 --> 00:54:32,520
starting around the motivation and then

1110
00:54:32,520 --> 00:54:34,980
I textual Concepts inside and user

1111
00:54:34,980 --> 00:54:36,359
interface okay

1112
00:54:36,359 --> 00:54:38,819
the first questions data is too big to

1113
00:54:38,819 --> 00:54:42,660
store on one version so what is solution

1114
00:54:42,660 --> 00:54:45,119
now you are you you are the designer of

1115
00:54:45,119 --> 00:54:47,960
the hdfs

1116
00:54:48,900 --> 00:54:51,300
data is too big to store on one machine

1117
00:54:51,300 --> 00:54:53,880
break it up and

1118
00:54:53,880 --> 00:54:56,940
so data is still is too big to store on

1119
00:54:56,940 --> 00:54:59,099
one version

1120
00:54:59,099 --> 00:55:00,900
yeah

1121
00:55:00,900 --> 00:55:03,180
store on multiple machines so we store

1122
00:55:03,180 --> 00:55:04,980
the data on multiple machines will break

1123
00:55:04,980 --> 00:55:07,500
the data up into many parts and restore

1124
00:55:07,500 --> 00:55:10,140
it into multiple machines

1125
00:55:10,140 --> 00:55:13,880
the next question yes

1126
00:55:21,540 --> 00:55:24,240
where how many drives you can hold in

1127
00:55:24,240 --> 00:55:28,440
one server how many drives you can have

1128
00:55:28,440 --> 00:55:29,720
it's

1129
00:55:29,720 --> 00:55:32,940
terabytes or petabytes of data

1130
00:55:32,940 --> 00:55:36,839
is it huge it's huge can you put one

1131
00:55:36,839 --> 00:55:41,400
like 10 000 of the drivers in one server

1132
00:55:41,400 --> 00:55:43,680
you do not have that power supply to

1133
00:55:43,680 --> 00:55:46,640
support it

1134
00:55:50,760 --> 00:55:54,420
how much space well you you you you have

1135
00:55:54,420 --> 00:55:55,559
you

1136
00:55:55,559 --> 00:56:00,240
how large is your this case one terabyte

1137
00:56:00,240 --> 00:56:02,460
we are looking at the data of this size

1138
00:56:02,460 --> 00:56:06,559
see this side all sides over there

1139
00:56:07,980 --> 00:56:10,020
you see

1140
00:56:10,020 --> 00:56:12,020
we are looking at this

1141
00:56:12,020 --> 00:56:16,520
yoga Wise It's not terabytes

1142
00:56:19,140 --> 00:56:21,839
you you your server cannot hold one

1143
00:56:21,839 --> 00:56:24,000
thousand ten thousand servers okay let's

1144
00:56:24,000 --> 00:56:25,680
continue

1145
00:56:25,680 --> 00:56:28,020
so store the data on multiple machines

1146
00:56:28,020 --> 00:56:30,059
actually many machines store the data on

1147
00:56:30,059 --> 00:56:32,579
many machines okay see but let's say the

1148
00:56:32,579 --> 00:56:35,280
motivation question two very high end

1149
00:56:35,280 --> 00:56:37,619
machines are too expensive then what is

1150
00:56:37,619 --> 00:56:40,280
our solution

1151
00:56:40,500 --> 00:56:42,599
so we store the data we divide the data

1152
00:56:42,599 --> 00:56:44,280
into many parts and we put them into

1153
00:56:44,280 --> 00:56:47,220
many machines and what if we cannot

1154
00:56:47,220 --> 00:56:49,319
afford

1155
00:56:49,319 --> 00:56:51,420
expensive machines

1156
00:56:51,420 --> 00:56:53,900
yes

1157
00:56:58,079 --> 00:57:01,800
so what what text is curling so

1158
00:57:01,800 --> 00:57:04,460
how

1159
00:57:04,800 --> 00:57:07,440
yes very good use more cheaper machines

1160
00:57:07,440 --> 00:57:11,220
use more cheaper machines right if let's

1161
00:57:11,220 --> 00:57:13,380
say the data can put that into three

1162
00:57:13,380 --> 00:57:15,960
machines for three super motions then we

1163
00:57:15,960 --> 00:57:20,280
can choose 13 cheaper versions

1164
00:57:20,280 --> 00:57:23,640
30 is cheaper machines so this is hdfs

1165
00:57:23,640 --> 00:57:25,619
solution

1166
00:57:25,619 --> 00:57:27,319
you are smart

1167
00:57:27,319 --> 00:57:30,599
that is how the how they these two

1168
00:57:30,599 --> 00:57:32,280
software engineering they designed the

1169
00:57:32,280 --> 00:57:35,220
hdfs they think of the same way okay the

1170
00:57:35,220 --> 00:57:37,380
community Hardware will fail or fail

1171
00:57:37,380 --> 00:57:39,839
what if the hardware fail so Hardware

1172
00:57:39,839 --> 00:57:42,359
emits the disk disk fail let's say disk

1173
00:57:42,359 --> 00:57:43,800
fail

1174
00:57:43,800 --> 00:57:46,800
the disk fails

1175
00:57:46,800 --> 00:57:51,200
the hardware fails the hardware fails

1176
00:57:56,880 --> 00:58:00,059
yeah it's very good we are good so data

1177
00:58:00,059 --> 00:58:02,760
redundancy reduce the replications with

1178
00:58:02,760 --> 00:58:04,800
the software approach to handle the

1179
00:58:04,800 --> 00:58:07,559
hardware failures that's a that's a key

1180
00:58:07,559 --> 00:58:10,140
concept so if Hardware is easy to fail

1181
00:58:10,140 --> 00:58:12,660
then we use some like redundancy

1182
00:58:12,660 --> 00:58:15,540
replication approach

1183
00:58:15,540 --> 00:58:17,460
that's the same as this what happens to

1184
00:58:17,460 --> 00:58:19,980
the data if the machine store the data

1185
00:58:19,980 --> 00:58:22,740
fails so the data fails we do the

1186
00:58:22,740 --> 00:58:25,079
replicate the data we do some redundancy

1187
00:58:25,079 --> 00:58:27,059
okay redundancy we use the software

1188
00:58:27,059 --> 00:58:30,839
approach to handle the hardware failures

1189
00:58:30,839 --> 00:58:33,960
how can distributed machines organize

1190
00:58:33,960 --> 00:58:35,520
the data in a coordinated way

1191
00:58:35,520 --> 00:58:38,160
accordingly or these questions let me

1192
00:58:38,160 --> 00:58:41,280
cross clarify this problem okay this

1193
00:58:41,280 --> 00:58:44,660
problem this problem asks you

1194
00:58:46,260 --> 00:58:48,960
how you going to disease you need to you

1195
00:58:48,960 --> 00:58:51,299
you have the input like when we talk

1196
00:58:51,299 --> 00:58:52,980
about system we will always talk about

1197
00:58:52,980 --> 00:58:56,579
before you for every system's design

1198
00:58:56,579 --> 00:58:59,280
okay when you are when you intend to

1199
00:58:59,280 --> 00:59:02,819
Design Systems you do not start from the

1200
00:59:02,819 --> 00:59:05,460
scratch do not start like calling it

1201
00:59:05,460 --> 00:59:07,920
think of that think of the input what

1202
00:59:07,920 --> 00:59:09,359
will be the input what will be the

1203
00:59:09,359 --> 00:59:10,920
output what will be the requirements

1204
00:59:10,920 --> 00:59:13,740
right so here the input is a bunch of

1205
00:59:13,740 --> 00:59:17,339
data a lot of data this is the inputs

1206
00:59:17,339 --> 00:59:19,319
and what I have what I have the hardware

1207
00:59:19,319 --> 00:59:22,740
I have is that the input is like many

1208
00:59:22,740 --> 00:59:25,200
many chip machines they are easy to fail

1209
00:59:25,200 --> 00:59:28,140
Okay so

1210
00:59:28,140 --> 00:59:31,680
what I have is some cheap motions what I

1211
00:59:31,680 --> 00:59:34,799
have is a lot of a lot a large amount of

1212
00:59:34,799 --> 00:59:36,720
data different data formats like

1213
00:59:36,720 --> 00:59:38,660
pictures images

1214
00:59:38,660 --> 00:59:43,280
documents PDFs movies

1215
00:59:43,400 --> 00:59:47,040
right so these are files so how can we

1216
00:59:47,040 --> 00:59:49,559
distribute the machines over like this

1217
00:59:49,559 --> 00:59:52,260
file in a coordinate way so how to do

1218
00:59:52,260 --> 00:59:53,280
that

1219
00:59:53,280 --> 00:59:57,359
how we're going to module

1220
00:59:57,920 --> 01:00:00,480
what are other architectures you have in

1221
01:00:00,480 --> 01:00:01,799
mind

1222
01:00:01,799 --> 01:00:05,119
that is my one my slides has

1223
01:00:05,119 --> 01:00:07,799
other architectures that you you have in

1224
01:00:07,799 --> 01:00:09,839
mind you basically ask you how you're

1225
01:00:09,839 --> 01:00:12,119
going to

1226
01:00:12,119 --> 01:00:14,280
how you're going to distribute the data

1227
01:00:14,280 --> 01:00:17,579
into many machines like the example I

1228
01:00:17,579 --> 01:00:20,819
gave to you is that I have many 10 100

1229
01:00:20,819 --> 01:00:23,339
thousands of documents that lead me to

1230
01:00:23,339 --> 01:00:25,260
help need you to help me

1231
01:00:25,260 --> 01:00:28,140
convert it into the PDF right I said

1232
01:00:28,140 --> 01:00:30,540
that I am the teacher so I assign this

1233
01:00:30,540 --> 01:00:33,000
work to you you guys each finish it for

1234
01:00:33,000 --> 01:00:35,520
me that is the master and the slave

1235
01:00:35,520 --> 01:00:37,680
architecture I'm the master you are a

1236
01:00:37,680 --> 01:00:40,940
slave okay no offense okay

1237
01:00:40,940 --> 01:00:44,099
that is the Master's life architecture

1238
01:00:44,099 --> 01:00:46,140
that's a muscle sleep architecture other

1239
01:00:46,140 --> 01:00:48,839
architectures you might think of that

1240
01:00:48,839 --> 01:00:52,579
you know other architectures yeah

1241
01:00:52,579 --> 01:00:55,980
what is exactly peer-to-peer anyone

1242
01:00:55,980 --> 01:00:57,900
heard of peer-to-peer

1243
01:00:57,900 --> 01:01:00,359
a lot of peer-to-peer yeah what is

1244
01:01:00,359 --> 01:01:03,079
peer-to-peer

1245
01:01:16,980 --> 01:01:19,380
yeah very good so it's not a permission

1246
01:01:19,380 --> 01:01:22,200
and access level it's like peer-to-peer

1247
01:01:22,200 --> 01:01:25,500
model means that I'm like you there's no

1248
01:01:25,500 --> 01:01:27,660
distinguish between the master and the

1249
01:01:27,660 --> 01:01:29,099
slaves okay

1250
01:01:29,099 --> 01:01:33,420
I'm like you you like me so we we

1251
01:01:33,420 --> 01:01:35,760
are the same peers that is the

1252
01:01:35,760 --> 01:01:39,059
peer-to-peer we have the same duties and

1253
01:01:39,059 --> 01:01:42,299
responsibilities so sometimes you make

1254
01:01:42,299 --> 01:01:45,119
you make the decision for me and I make

1255
01:01:45,119 --> 01:01:47,220
the decision for you and you also make

1256
01:01:47,220 --> 01:01:49,380
the decision for your labors so that is

1257
01:01:49,380 --> 01:01:51,780
appeal to peer peer-to-peer it's like

1258
01:01:51,780 --> 01:01:54,359
everyone can behave like a server

1259
01:01:54,359 --> 01:01:58,020
everyone and any like a master everyone

1260
01:01:58,020 --> 01:02:02,099
can also behave as a slave so you and

1261
01:02:02,099 --> 01:02:04,440
then the system can decide who will be

1262
01:02:04,440 --> 01:02:06,720
the slave who will be the master in

1263
01:02:06,720 --> 01:02:09,240
which circumstances but most of times

1264
01:02:09,240 --> 01:02:12,000
you guys have the same Duty and

1265
01:02:12,000 --> 01:02:14,460
responsibilities so the peer-to-peer

1266
01:02:14,460 --> 01:02:16,859
architecture has been commonly used in

1267
01:02:16,859 --> 01:02:19,980
many software like scalable software

1268
01:02:19,980 --> 01:02:22,200
like

1269
01:02:22,200 --> 01:02:25,819
um Skype Skype

1270
01:02:26,220 --> 01:02:28,920
Skype right you subscribe my many times

1271
01:02:28,920 --> 01:02:31,200
right the the phone

1272
01:02:31,200 --> 01:02:33,240
the underlying protocol is the

1273
01:02:33,240 --> 01:02:34,740
peer-to-peer protocol

1274
01:02:34,740 --> 01:02:36,420
BT tolerance

1275
01:02:36,420 --> 01:02:38,760
Beauty tolerance is also a very classic

1276
01:02:38,760 --> 01:02:41,480
software of the peer-to-peer system

1277
01:02:41,480 --> 01:02:43,859
season 2 and

1278
01:02:43,859 --> 01:02:45,359
um

1279
01:02:45,359 --> 01:02:48,900
YouTube is not YouTube is not okay

1280
01:02:48,900 --> 01:02:49,619
um

1281
01:02:49,619 --> 01:02:51,599
what are the architectures what other

1282
01:02:51,599 --> 01:02:54,059
architectures you might think of that

1283
01:02:54,059 --> 01:02:57,260
Master Slave

1284
01:02:58,200 --> 01:03:01,579
one master designed distributed work to

1285
01:03:01,579 --> 01:03:04,140
slaves and slaves to the same work then

1286
01:03:04,140 --> 01:03:06,500
combined Master combined results

1287
01:03:06,500 --> 01:03:09,420
peer-to-peer means that okay everyone

1288
01:03:09,420 --> 01:03:12,119
can be have the same duties and

1289
01:03:12,119 --> 01:03:15,000
responsibilities so you contribute one

1290
01:03:15,000 --> 01:03:16,980
contributes to all what contributes to

1291
01:03:16,980 --> 01:03:19,380
one like

1292
01:03:19,380 --> 01:03:23,660
is a famous saying about us like I

1293
01:03:23,660 --> 01:03:26,400
so you work for everyone and everyone is

1294
01:03:26,400 --> 01:03:28,020
working for you something like that so

1295
01:03:28,020 --> 01:03:30,000
that is peer-to-peer architecture any

1296
01:03:30,000 --> 01:03:32,280
other architectures

1297
01:03:32,280 --> 01:03:34,559
any other architecture

1298
01:03:34,559 --> 01:03:37,760
or single creatively

1299
01:03:40,140 --> 01:03:41,819
hierarchical architecture right

1300
01:03:41,819 --> 01:03:43,859
hierarchical architecture right

1301
01:03:43,859 --> 01:03:45,900
hierarchical architecture so it's not

1302
01:03:45,900 --> 01:03:48,000
just the Master Slave it's maybe half a

1303
01:03:48,000 --> 01:03:49,079
master

1304
01:03:49,079 --> 01:03:50,400
and then

1305
01:03:50,400 --> 01:03:53,040
it's actually have like master and then

1306
01:03:53,040 --> 01:03:55,680
maybe some small Master like

1307
01:03:55,680 --> 01:03:58,500
then a slave I don't know it has two

1308
01:03:58,500 --> 01:04:01,380
layers it may have many many layers that

1309
01:04:01,380 --> 01:04:05,099
is a hierarchical architecture what else

1310
01:04:05,099 --> 01:04:07,640
yes

1311
01:04:08,819 --> 01:04:12,960
the same it's the same client server

1312
01:04:12,960 --> 01:04:14,700
well here's the thing when we are

1313
01:04:14,700 --> 01:04:17,339
talking master and slave

1314
01:04:17,339 --> 01:04:19,740
you will think of the situation for one

1315
01:04:19,740 --> 01:04:21,599
master and a 10 slave something like

1316
01:04:21,599 --> 01:04:23,640
this but while you're talking about the

1317
01:04:23,640 --> 01:04:25,380
several clients it's maybe only one

1318
01:04:25,380 --> 01:04:27,299
server for one client

1319
01:04:27,299 --> 01:04:30,240
so the muscle slave is more

1320
01:04:30,240 --> 01:04:31,500
um

1321
01:04:31,500 --> 01:04:34,020
because it's a slave right many slaves a

1322
01:04:34,020 --> 01:04:36,720
master have many sleeves it's not like a

1323
01:04:36,720 --> 01:04:39,660
server has many clients and sometimes

1324
01:04:39,660 --> 01:04:41,520
the server can only have

1325
01:04:41,520 --> 01:04:43,380
several clients

1326
01:04:43,380 --> 01:04:45,839
okay so but it's one part is the same

1327
01:04:45,839 --> 01:04:49,140
it's actually very similar

1328
01:04:49,140 --> 01:04:51,240
where we have Master Slave architecture

1329
01:04:51,240 --> 01:04:54,420
oh I will post some some architecture to

1330
01:04:54,420 --> 01:04:56,099
you okay we have a Master Slave

1331
01:04:56,099 --> 01:04:58,020
architecture hierarchical architecture

1332
01:04:58,020 --> 01:05:00,780
peer-to-peer architecture what we can

1333
01:05:00,780 --> 01:05:02,880
have is a hybrid architecture hybrid

1334
01:05:02,880 --> 01:05:04,859
architecture means that it's a mix of

1335
01:05:04,859 --> 01:05:07,500
it's me let's say it's mix of the muscle

1336
01:05:07,500 --> 01:05:09,839
strength and peer-to-peer for example in

1337
01:05:09,839 --> 01:05:11,640
the peer-to-peer you can save some node

1338
01:05:11,640 --> 01:05:14,040
as a super low the super node has some

1339
01:05:14,040 --> 01:05:17,220
master attributes this is the system

1340
01:05:17,220 --> 01:05:19,680
architecture used in the Skype protocol

1341
01:05:19,680 --> 01:05:22,079
Sky protocol

1342
01:05:22,079 --> 01:05:24,299
um what else yeah there are many

1343
01:05:24,299 --> 01:05:27,180
different architectures but the takeaway

1344
01:05:27,180 --> 01:05:30,000
here is that hdfs use master and slave

1345
01:05:30,000 --> 01:05:32,339
architecture so what exactly must the

1346
01:05:32,339 --> 01:05:33,900
slave attention here in the master

1347
01:05:33,900 --> 01:05:36,780
here's the slaves okay the master is a

1348
01:05:36,780 --> 01:05:39,359
one note it's a one server so here in

1349
01:05:39,359 --> 01:05:42,720
the system we have seven servers seven

1350
01:05:42,720 --> 01:05:44,520
servers

1351
01:05:44,520 --> 01:05:46,700
now these seven servers together

1352
01:05:46,700 --> 01:05:49,559
constitute a file system record or

1353
01:05:49,559 --> 01:05:53,280
distributed file systems so

1354
01:05:53,280 --> 01:05:55,559
when we're talking about file systems

1355
01:05:55,559 --> 01:05:57,359
we're talking about an important

1356
01:05:57,359 --> 01:05:59,579
Concepts right

1357
01:05:59,579 --> 01:06:02,059
foreign

1358
01:06:04,880 --> 01:06:07,980
give you something okay when we're

1359
01:06:07,980 --> 01:06:10,859
talking about the file systems we we're

1360
01:06:10,859 --> 01:06:12,540
talking about an important abstraction

1361
01:06:12,540 --> 01:06:15,720
it's called the

1362
01:06:15,720 --> 01:06:18,240
I know the right I know we say that

1363
01:06:18,240 --> 01:06:21,180
every file has an inode right every

1364
01:06:21,180 --> 01:06:23,579
files has a i node every files has an

1365
01:06:23,579 --> 01:06:26,400
inode now the slaves

1366
01:06:26,400 --> 01:06:29,339
so where I should put I node in this

1367
01:06:29,339 --> 01:06:31,020
case

1368
01:06:31,020 --> 01:06:33,900
I have many files right

1369
01:06:33,900 --> 01:06:37,079
so each file profile has an inode I know

1370
01:06:37,079 --> 01:06:39,599
it's like a metadata of this file right

1371
01:06:39,599 --> 01:06:42,000
the metadata of this file so where I

1372
01:06:42,000 --> 01:06:44,520
should put the inode much

1373
01:06:44,520 --> 01:06:48,359
Master we as Master Guard all I know the

1374
01:06:48,359 --> 01:06:50,039
information or I know the information

1375
01:06:50,039 --> 01:06:53,160
then farewell we've put the files in

1376
01:06:53,160 --> 01:06:55,740
these slaves right they are the data

1377
01:06:55,740 --> 01:06:59,119
node they are the data node

1378
01:06:59,400 --> 01:07:02,940
so the master master

1379
01:07:02,940 --> 01:07:06,200
is called the

1380
01:07:06,359 --> 01:07:09,180
name node we call it a name node it's

1381
01:07:09,180 --> 01:07:12,599
it's saved information it's a safe

1382
01:07:12,599 --> 01:07:15,420
information name node okay save the

1383
01:07:15,420 --> 01:07:18,299
information of all I node I know the

1384
01:07:18,299 --> 01:07:21,000
information of the files files and

1385
01:07:21,000 --> 01:07:23,700
install it okay I know the shows to

1386
01:07:23,700 --> 01:07:25,500
block mappings right that I what I told

1387
01:07:25,500 --> 01:07:28,319
you right I noticed the blocking address

1388
01:07:28,319 --> 01:07:31,079
of each file that is the from the

1389
01:07:31,079 --> 01:07:34,319
virtual block number to the physical to

1390
01:07:34,319 --> 01:07:36,299
the physical address in the disk that is

1391
01:07:36,299 --> 01:07:39,260
the block mappings

1392
01:07:39,299 --> 01:07:42,359
so the I know the information all the

1393
01:07:42,359 --> 01:07:44,880
files I know the information is in the

1394
01:07:44,880 --> 01:07:47,099
master it's in the master

1395
01:07:47,099 --> 01:07:50,819
and then the data node data node

1396
01:07:50,819 --> 01:07:55,880
data node is responsible to saving the

1397
01:07:56,339 --> 01:07:59,160
to save in the files

1398
01:07:59,160 --> 01:08:01,440
and doing the replication why we need to

1399
01:08:01,440 --> 01:08:02,940
do the replication

1400
01:08:02,940 --> 01:08:05,339
what we need to do application because

1401
01:08:05,339 --> 01:08:07,200
at the beginning we're saying that we

1402
01:08:07,200 --> 01:08:08,940
are using chip machines and shipping

1403
01:08:08,940 --> 01:08:14,520
machines are easy to fail if the if the

1404
01:08:14,520 --> 01:08:17,640
node fails then we lost the data so we

1405
01:08:17,640 --> 01:08:20,660
do some replication

1406
01:08:20,819 --> 01:08:24,500
for failure recovery right

1407
01:08:27,540 --> 01:08:29,939
over here what is the secondary limb

1408
01:08:29,939 --> 01:08:31,080
node

1409
01:08:31,080 --> 01:08:33,238
Master is the name node right what is

1410
01:08:33,238 --> 01:08:35,279
the second rename node

1411
01:08:35,279 --> 01:08:37,699
foreign

1412
01:08:50,640 --> 01:08:53,399
useful for to do the Fatal recovery of

1413
01:08:53,399 --> 01:08:55,500
the master of the master that is the

1414
01:08:55,500 --> 01:08:59,120
secondary name node okay

1415
01:09:00,779 --> 01:09:03,380
okay so let's look at the

1416
01:09:03,380 --> 01:09:06,779
hdfs structure this is the Master Slave

1417
01:09:06,779 --> 01:09:08,219
structure okay

1418
01:09:08,219 --> 01:09:10,319
hmm

1419
01:09:10,319 --> 01:09:12,600
so we bought

1420
01:09:12,600 --> 01:09:15,359
the file system this is a architecture

1421
01:09:15,359 --> 01:09:17,880
of the distributed file system

1422
01:09:17,880 --> 01:09:20,000
um

1423
01:09:20,698 --> 01:09:22,439
so

1424
01:09:22,439 --> 01:09:24,600
let's say you come now you join your big

1425
01:09:24,600 --> 01:09:26,819
company like VMware VMware is actually

1426
01:09:26,819 --> 01:09:29,698
using this okay they have many servers

1427
01:09:29,698 --> 01:09:33,719
10 100 servers okay the servers rack do

1428
01:09:33,719 --> 01:09:36,359
you know what is rack Rack anyone heard

1429
01:09:36,359 --> 01:09:37,920
of rack

1430
01:09:37,920 --> 01:09:40,920
Magic

1431
01:09:41,040 --> 01:09:43,738
thing that they put on the servers yeah

1432
01:09:43,738 --> 01:09:45,779
the physical the server is low like your

1433
01:09:45,779 --> 01:09:48,238
desktop server like this the server is

1434
01:09:48,238 --> 01:09:51,120
is look like the shape of braid

1435
01:09:51,120 --> 01:09:52,979
it's like this

1436
01:09:52,979 --> 01:09:56,280
you see anyone see the real server yeah

1437
01:09:56,280 --> 01:09:59,460
yeah it and then we insert that into the

1438
01:09:59,460 --> 01:10:02,400
rack so a rack will have like 40 servers

1439
01:10:02,400 --> 01:10:04,679
usually you're the most times a record

1440
01:10:04,679 --> 01:10:07,820
have 40 servers

1441
01:10:08,100 --> 01:10:10,320
inside of the rack their communication

1442
01:10:10,320 --> 01:10:12,600
is very fast but between the racks

1443
01:10:12,600 --> 01:10:14,280
between the racks the communication is

1444
01:10:14,280 --> 01:10:17,000
slow why

1445
01:10:18,540 --> 01:10:21,300
because the Rocks rocks to rocks needs

1446
01:10:21,300 --> 01:10:26,159
to use the switch switch is slow

1447
01:10:26,159 --> 01:10:29,640
and then after the switch we have the oh

1448
01:10:29,640 --> 01:10:32,480
okay it is sometimes it's used

1449
01:10:32,480 --> 01:10:35,520
to actually use the top of rack servers

1450
01:10:35,520 --> 01:10:38,520
on top of rack router and then on top of

1451
01:10:38,520 --> 01:10:41,040
rack router to talk about the rock

1452
01:10:41,040 --> 01:10:43,260
launcher using the switch and it's

1453
01:10:43,260 --> 01:10:45,239
slower and slower that is the tree

1454
01:10:45,239 --> 01:10:47,940
structure of the data center

1455
01:10:47,940 --> 01:10:50,640
okay so we we have the machine we have

1456
01:10:50,640 --> 01:10:53,219
the servers okay this the data node data

1457
01:10:53,219 --> 01:10:55,440
node they are there they are in

1458
01:10:55,440 --> 01:10:57,179
different racks in different like their

1459
01:10:57,179 --> 01:10:59,400
data not in different racks okay the

1460
01:10:59,400 --> 01:11:02,100
data our data is there and then we have

1461
01:11:02,100 --> 01:11:04,260
the name node okay each rack have a name

1462
01:11:04,260 --> 01:11:05,520
node okay

1463
01:11:05,520 --> 01:11:07,699
foreign

1464
01:11:12,920 --> 01:11:16,260
mappings of this data nodes this data

1465
01:11:16,260 --> 01:11:19,500
and we have a secondary name node okay

1466
01:11:19,500 --> 01:11:22,560
secondary name node now here's the

1467
01:11:22,560 --> 01:11:26,000
question here's the question

1468
01:11:29,159 --> 01:11:31,140
we know that we are going to use the

1469
01:11:31,140 --> 01:11:34,560
replication approach to replicate the

1470
01:11:34,560 --> 01:11:37,320
data right

1471
01:11:37,320 --> 01:11:40,440
what is a replication Factor

1472
01:11:40,440 --> 01:11:45,080
replica replication Factor

1473
01:11:45,540 --> 01:11:46,980
how many

1474
01:11:46,980 --> 01:11:51,440
how many how many let's say

1475
01:11:52,440 --> 01:11:55,080
if this racks fails right all the data

1476
01:11:55,080 --> 01:11:57,960
belonging to disrupt or will be lost if

1477
01:11:57,960 --> 01:12:01,140
the replication factor in equals to one

1478
01:12:01,140 --> 01:12:03,719
then that means there's low replica

1479
01:12:03,719 --> 01:12:06,000
if it is equal to one then that means

1480
01:12:06,000 --> 01:12:09,480
there's no replica right sorry no no if

1481
01:12:09,480 --> 01:12:11,040
it equals to zero then that means

1482
01:12:11,040 --> 01:12:13,140
there's no replica so if there's no

1483
01:12:13,140 --> 01:12:15,540
replica then whatever the data here is

1484
01:12:15,540 --> 01:12:16,679
lost

1485
01:12:16,679 --> 01:12:18,960
there's no way to retrieve the data you

1486
01:12:18,960 --> 01:12:20,760
have to do the things all again you have

1487
01:12:20,760 --> 01:12:22,620
to ask your Masters give me the file

1488
01:12:22,620 --> 01:12:25,260
again so the master downloads the files

1489
01:12:25,260 --> 01:12:27,120
again and give it to you and needs to

1490
01:12:27,120 --> 01:12:29,520
check what you have and you can give the

1491
01:12:29,520 --> 01:12:31,140
file to you again

1492
01:12:31,140 --> 01:12:33,659
this is very incompicious right so we

1493
01:12:33,659 --> 01:12:36,420
use a replica replication but what is

1494
01:12:36,420 --> 01:12:40,199
the replication Factor like how many

1495
01:12:40,199 --> 01:12:43,199
copies that you need

1496
01:12:43,199 --> 01:12:45,360
for each machine and where do you save

1497
01:12:45,360 --> 01:12:48,080
these copies

1498
01:12:48,719 --> 01:12:50,699
let's say the copies we only need one

1499
01:12:50,699 --> 01:12:53,219
copy okay so we store for each machine

1500
01:12:53,219 --> 01:12:55,800
with each machine we store one copy of

1501
01:12:55,800 --> 01:12:58,920
their code their data where do we store

1502
01:12:58,920 --> 01:13:02,600
where do we store

1503
01:13:03,480 --> 01:13:06,260
where yes

1504
01:13:07,940 --> 01:13:12,420
very good I put you put it into this

1505
01:13:12,420 --> 01:13:16,800
difference rank difference reacts

1506
01:13:16,800 --> 01:13:19,140
but what if they what if you for

1507
01:13:19,140 --> 01:13:20,880
different racks you need to go through

1508
01:13:20,880 --> 01:13:23,100
this switch right so I already told you

1509
01:13:23,100 --> 01:13:26,179
the situation is slow

1510
01:13:28,380 --> 01:13:30,659
right then one replica may not in love

1511
01:13:30,659 --> 01:13:33,960
so let's say I choose two replicas

1512
01:13:33,960 --> 01:13:37,980
that is stored in one of the rocks

1513
01:13:37,980 --> 01:13:41,100
let's say this this for these files

1514
01:13:41,100 --> 01:13:43,920
replica I saw it on different drugs than

1515
01:13:43,920 --> 01:13:45,239
what else

1516
01:13:45,239 --> 01:13:47,219
where I should store this replica

1517
01:13:47,219 --> 01:13:50,400
another another replica

1518
01:13:50,400 --> 01:13:52,199
huh

1519
01:13:52,199 --> 01:13:54,480
and the original rack very good cause

1520
01:13:54,480 --> 01:13:57,120
original record like laboring node for

1521
01:13:57,120 --> 01:14:00,300
the laboring node is very fast right

1522
01:14:00,300 --> 01:14:01,980
you do not need to go through the

1523
01:14:01,980 --> 01:14:05,219
switches it's very fast right so you can

1524
01:14:05,219 --> 01:14:09,260
push it simply there simply there

1525
01:14:10,140 --> 01:14:12,719
then how about the

1526
01:14:12,719 --> 01:14:17,179
okay let's continue okay let's continue

1527
01:14:24,840 --> 01:14:27,780
so the name node knows all blocks and

1528
01:14:27,780 --> 01:14:30,120
replicas name node notes all the block

1529
01:14:30,120 --> 01:14:33,620
mappings and replicas yes

1530
01:14:40,440 --> 01:14:43,679
they they are using the uh

1531
01:14:43,679 --> 01:14:46,280
I think it's around the 10 gigabytes of

1532
01:14:46,280 --> 01:14:49,100
intro landscape

1533
01:14:49,100 --> 01:14:53,100
local area land work

1534
01:14:53,100 --> 01:14:55,860
yeah yeah yeah they're just the cables

1535
01:14:55,860 --> 01:14:57,360
this is what you should learn in the

1536
01:14:57,360 --> 01:14:59,100
light working class right they are

1537
01:14:59,100 --> 01:15:01,940
definitely not connected with Wi-Fi

1538
01:15:01,940 --> 01:15:03,480
yeah

1539
01:15:03,480 --> 01:15:07,040
so this is a data center yes

1540
01:15:14,699 --> 01:15:16,320
yes

1541
01:15:16,320 --> 01:15:20,100
we think the rack is always the fast

1542
01:15:20,100 --> 01:15:24,560
if I'm if we are in the

1543
01:15:25,320 --> 01:15:27,780
um so right now you may not that kind of

1544
01:15:27,780 --> 01:15:29,699
that impression because everyone is

1545
01:15:29,699 --> 01:15:31,980
using Wi-Fi so you have you do not

1546
01:15:31,980 --> 01:15:34,679
realize the speed differences between

1547
01:15:34,679 --> 01:15:37,320
the rats and then across the Rocks we

1548
01:15:37,320 --> 01:15:39,659
see the Rock and of course the Rock

1549
01:15:39,659 --> 01:15:41,719
um

1550
01:15:41,940 --> 01:15:44,699
think of the case I have a your I have a

1551
01:15:44,699 --> 01:15:47,460
I'm in the lab I have a file and I need

1552
01:15:47,460 --> 01:15:50,940
to transfer it to my to my another lab

1553
01:15:50,940 --> 01:15:53,400
makes Liam me so we both connected with

1554
01:15:53,400 --> 01:15:56,340
L in the cable cable right so very fast

1555
01:15:56,340 --> 01:15:58,980
it's it's between us is very fast but

1556
01:15:58,980 --> 01:16:00,840
how about another lab mate who is in

1557
01:16:00,840 --> 01:16:01,620
China

1558
01:16:01,620 --> 01:16:04,620
it's very slow it will be very slow

1559
01:16:04,620 --> 01:16:08,340
because he needs to go over a lot of

1560
01:16:08,340 --> 01:16:10,199
switches

1561
01:16:10,199 --> 01:16:12,800
yes

1562
01:16:16,320 --> 01:16:18,000
oh that's good that's a very good

1563
01:16:18,000 --> 01:16:20,580
question they are actually

1564
01:16:20,580 --> 01:16:22,560
so there are there's something the

1565
01:16:22,560 --> 01:16:25,260
picture does not draw everything okay

1566
01:16:25,260 --> 01:16:28,140
in the big data center like Amazon ec2

1567
01:16:28,140 --> 01:16:30,060
what they have is that they have the

1568
01:16:30,060 --> 01:16:32,640
concept of the songs away they first

1569
01:16:32,640 --> 01:16:35,820
have the concept of regions

1570
01:16:35,820 --> 01:16:37,500
how many regions do you know the Amazon

1571
01:16:37,500 --> 01:16:39,780
used to has they have seven different

1572
01:16:39,780 --> 01:16:42,060
data centers

1573
01:16:42,060 --> 01:16:46,260
the two invert why is it in Virginia why

1574
01:16:46,260 --> 01:16:48,300
is in Ohio

1575
01:16:48,300 --> 01:16:50,360
um

1576
01:16:51,480 --> 01:16:54,600
I do not think California has one but

1577
01:16:54,600 --> 01:16:57,540
yeah I may forget but Tokyo has one and

1578
01:16:57,540 --> 01:16:58,520
uh

1579
01:16:58,520 --> 01:17:02,280
Japan has another one they have uh I

1580
01:17:02,280 --> 01:17:05,400
think it's when I do the experiments I I

1581
01:17:05,400 --> 01:17:08,219
I you I think they have eight seven or

1582
01:17:08,219 --> 01:17:11,159
eight different data centers and that is

1583
01:17:11,159 --> 01:17:13,560
a data center concept and inside of each

1584
01:17:13,560 --> 01:17:16,679
data center there's a concept of the

1585
01:17:16,679 --> 01:17:19,560
um the Zone The Zone so what is the Zone

1586
01:17:19,560 --> 01:17:21,960
the zone is actually like the class the

1587
01:17:21,960 --> 01:17:24,719
the loom the loom concept because you

1588
01:17:24,719 --> 01:17:27,840
cannot hold order servers or together in

1589
01:17:27,840 --> 01:17:31,020
a place you need to save it in a

1590
01:17:31,020 --> 01:17:33,480
in different places the cooling is very

1591
01:17:33,480 --> 01:17:35,880
expensive cooling so they have the zones

1592
01:17:35,880 --> 01:17:38,699
they have many zones and inside of each

1593
01:17:38,699 --> 01:17:40,860
Zone then they have many racks

1594
01:17:40,860 --> 01:17:43,260
and some racks May in the same room some

1595
01:17:43,260 --> 01:17:46,699
rocks May in the different room yeah

1596
01:17:55,739 --> 01:17:59,100
yeah yeah the Rocks well well you you

1597
01:17:59,100 --> 01:18:01,020
think it's a hierarchical structure the

1598
01:18:01,020 --> 01:18:03,300
speed we think the rock is always the

1599
01:18:03,300 --> 01:18:05,699
fast always fast because they are in the

1600
01:18:05,699 --> 01:18:09,560
same Rock they are connected with the

1601
01:18:12,300 --> 01:18:17,360
multiple servers in your same physical

1602
01:18:22,800 --> 01:18:24,980
yeah

1603
01:18:25,260 --> 01:18:27,719
they are not as fast as within the same

1604
01:18:27,719 --> 01:18:29,640
rack because they all need to go stock

1605
01:18:29,640 --> 01:18:33,179
the top of rack router there's a there's

1606
01:18:33,179 --> 01:18:35,420
a

1607
01:18:35,640 --> 01:18:39,199
let me show you a picture okay this is

1608
01:18:39,199 --> 01:18:42,300
something that oh we should know that

1609
01:18:42,300 --> 01:18:45,179
okay let me see anything let me see if I

1610
01:18:45,179 --> 01:18:46,140
can find

1611
01:18:46,140 --> 01:18:48,800
this

1612
01:19:08,460 --> 01:19:11,540
yeah okay

1613
01:19:17,040 --> 01:19:18,480
can you see this

1614
01:19:18,480 --> 01:19:20,940
so this is the data centers

1615
01:19:20,940 --> 01:19:23,880
Factory cloud data center three tier

1616
01:19:23,880 --> 01:19:25,920
Factory topology

1617
01:19:25,920 --> 01:19:27,420
so here

1618
01:19:27,420 --> 01:19:30,060
if you are you are belonging to

1619
01:19:30,060 --> 01:19:32,219
different drugs

1620
01:19:32,219 --> 01:19:34,500
all the Motions are going to share the

1621
01:19:34,500 --> 01:19:37,260
same module here this is the router

1622
01:19:37,260 --> 01:19:39,960
it may have only eight

1623
01:19:39,960 --> 01:19:43,320
ports then here the rock each Rock have

1624
01:19:43,320 --> 01:19:47,760
40 servers so you have 100 hundreds of

1625
01:19:47,760 --> 01:19:50,280
um let's say 40 servers in each rack

1626
01:19:50,280 --> 01:19:52,500
then these are not a 40 servers is they

1627
01:19:52,500 --> 01:19:54,780
both need to communicate with the same

1628
01:19:54,780 --> 01:19:57,900
router it's slow because the bandwidth

1629
01:19:57,900 --> 01:20:00,300
is just that big

1630
01:20:00,300 --> 01:20:03,239
right the bandwidth is just that big so

1631
01:20:03,239 --> 01:20:05,699
that is why we're crossing the Rocks is

1632
01:20:05,699 --> 01:20:08,280
very slow the same thing as this if you

1633
01:20:08,280 --> 01:20:10,500
are you you want to go through this to

1634
01:20:10,500 --> 01:20:12,900
go to another Rack in another Zone that

1635
01:20:12,900 --> 01:20:15,920
is super slow why because many many

1636
01:20:15,920 --> 01:20:19,560
servers are concurrently used that they

1637
01:20:19,560 --> 01:20:22,320
are shared they are shared you see the

1638
01:20:22,320 --> 01:20:24,900
number is very limited every rack has

1639
01:20:24,900 --> 01:20:28,380
only one top of top of wrap server that

1640
01:20:28,380 --> 01:20:30,719
is why this is the factory structure at

1641
01:20:30,719 --> 01:20:32,880
the beginning of the data center they

1642
01:20:32,880 --> 01:20:35,219
use a tree structure

1643
01:20:35,219 --> 01:20:37,920
if you if you learn the if you take the

1644
01:20:37,920 --> 01:20:40,380
lateral cost they you will learn that

1645
01:20:40,380 --> 01:20:43,020
this is an important class about the

1646
01:20:43,020 --> 01:20:45,840
architecture okay of the data center so

1647
01:20:45,840 --> 01:20:48,060
here the what is the factory factory

1648
01:20:48,060 --> 01:20:50,699
means that I add more branches at the

1649
01:20:50,699 --> 01:20:54,600
top of the tree the tree itself is very

1650
01:20:54,600 --> 01:20:58,560
slim but for fat tree I add more routers

1651
01:20:58,560 --> 01:21:00,900
and more routers in each branches so

1652
01:21:00,900 --> 01:21:03,780
that's why I can increase this increase

1653
01:21:03,780 --> 01:21:05,280
the bandwidth

1654
01:21:05,280 --> 01:21:08,460
for this for for sharing it okay for

1655
01:21:08,460 --> 01:21:12,060
sharing that is a factory structure okay

1656
01:21:12,060 --> 01:21:14,840
okay

1657
01:21:15,540 --> 01:21:18,540
okay yes

1658
01:21:27,960 --> 01:21:29,880
if

1659
01:21:29,880 --> 01:21:33,679
if there's Not in Love

1660
01:21:38,300 --> 01:21:41,360
yes yes

1661
01:21:41,360 --> 01:21:43,920
that is the case go about the hardware

1662
01:21:43,920 --> 01:21:47,280
as there are developing very fast

1663
01:21:47,280 --> 01:21:49,140
so you should know it should not that

1664
01:21:49,140 --> 01:21:51,739
big problem

1665
01:21:53,219 --> 01:21:55,800
but if this is you ask actually very

1666
01:21:55,800 --> 01:21:58,020
good question you know the um my

1667
01:21:58,020 --> 01:22:00,239
otherwise are used to my PhD always used

1668
01:22:00,239 --> 01:22:03,239
to tell me he talked to a Google

1669
01:22:03,239 --> 01:22:03,980
um

1670
01:22:03,980 --> 01:22:07,380
Google senior engineering is almost like

1671
01:22:07,380 --> 01:22:09,600
top top top five Engineering in the

1672
01:22:09,600 --> 01:22:12,780
Google and the data engineering told him

1673
01:22:12,780 --> 01:22:16,080
that Google Google has many ways of

1674
01:22:16,080 --> 01:22:18,780
saving the data replicates the data and

1675
01:22:18,780 --> 01:22:21,060
make the best use of data but Google has

1676
01:22:21,060 --> 01:22:24,840
not developed a good policy for deleting

1677
01:22:24,840 --> 01:22:28,280
the data because Google has no idea like

1678
01:22:28,280 --> 01:22:30,540
why like

1679
01:22:30,540 --> 01:22:33,179
like whether you may need that data or

1680
01:22:33,179 --> 01:22:35,880
not so he will what Google did his touch

1681
01:22:35,880 --> 01:22:38,900
he several times set a time for everyone

1682
01:22:38,900 --> 01:22:41,880
for storing the data for a super long

1683
01:22:41,880 --> 01:22:44,520
time but actually everyone has many data

1684
01:22:44,520 --> 01:22:46,920
like 90 percentage that they do not need

1685
01:22:46,920 --> 01:22:49,320
that but Google will not delete that

1686
01:22:49,320 --> 01:22:50,880
because

1687
01:22:50,880 --> 01:22:53,400
he doesn't he has no idea whether you

1688
01:22:53,400 --> 01:22:55,800
will use it in the future that's what

1689
01:22:55,800 --> 01:22:57,540
they are challenging okay they're

1690
01:22:57,540 --> 01:22:58,800
challenging because they want to make

1691
01:22:58,800 --> 01:23:01,380
the best use of the storage space okay

1692
01:23:01,380 --> 01:23:05,480
so let's look keep looking at this okay

1693
01:23:05,580 --> 01:23:08,580
oh

1694
01:23:13,320 --> 01:23:16,100
okay

1695
01:23:20,940 --> 01:23:23,480
okay

1696
01:23:23,960 --> 01:23:27,960
so what if the whole Rock got

1697
01:23:27,960 --> 01:23:30,780
failed then we need to replicate another

1698
01:23:30,780 --> 01:23:33,360
copy right in another rack

1699
01:23:33,360 --> 01:23:35,780
right

1700
01:23:38,580 --> 01:23:41,159
so what if the name node got down what

1701
01:23:41,159 --> 01:23:44,400
is the name sorry the muscle no get down

1702
01:23:44,400 --> 01:23:46,800
then we need a secondary name known

1703
01:23:46,800 --> 01:23:50,340
right the secondary lame node secondary

1704
01:23:50,340 --> 01:23:53,460
name node is doing the Master Copy how

1705
01:23:53,460 --> 01:23:55,320
about the network performance okay it

1706
01:23:55,320 --> 01:23:59,600
tells you the network performance okay

1707
01:24:00,239 --> 01:24:03,239
keep bounding communication with single

1708
01:24:03,239 --> 01:24:05,760
rack so we think the information is

1709
01:24:05,760 --> 01:24:09,780
always faster and efficient do not go

1710
01:24:09,780 --> 01:24:12,300
over that if you go over higher and

1711
01:24:12,300 --> 01:24:16,020
higher layers it will be slow and slower

1712
01:24:16,020 --> 01:24:18,239
Okay so

1713
01:24:18,239 --> 01:24:21,739
let's look at this okay

1714
01:24:22,140 --> 01:24:24,000
so if we have a file name the

1715
01:24:24,000 --> 01:24:26,820
replication factor is three and then the

1716
01:24:26,820 --> 01:24:30,300
block ID is one two three so we are

1717
01:24:30,300 --> 01:24:31,560
going to have

1718
01:24:31,560 --> 01:24:35,100
we're going to like file one so file one

1719
01:24:35,100 --> 01:24:37,500
this has three replication factors the

1720
01:24:37,500 --> 01:24:39,900
block ID is one two three so you can see

1721
01:24:39,900 --> 01:24:42,179
that one two three is replicated in

1722
01:24:42,179 --> 01:24:44,159
three different nodes right three

1723
01:24:44,159 --> 01:24:47,280
different nodes so what is what if the

1724
01:24:47,280 --> 01:24:49,380
file two has the replication factor of

1725
01:24:49,380 --> 01:24:51,840
two then the block ID is four five six

1726
01:24:51,840 --> 01:24:53,940
so you can see that four five six four

1727
01:24:53,940 --> 01:24:58,440
five six so you see there's only two

1728
01:24:58,440 --> 01:25:02,480
replicas right two replicas

1729
01:25:02,640 --> 01:25:05,760
two copies of this file tool right if

1730
01:25:05,760 --> 01:25:07,920
the file 3 has the replication factor of

1731
01:25:07,920 --> 01:25:10,560
1 the block ID 7 8 then we can see seven

1732
01:25:10,560 --> 01:25:12,840
and it's there's no replica there's no

1733
01:25:12,840 --> 01:25:16,880
replica okay there's no replica

1734
01:25:17,400 --> 01:25:19,860
and the default replica the application

1735
01:25:19,860 --> 01:25:22,620
number for the hdfs is

1736
01:25:22,620 --> 01:25:25,679
is how much anyone's any student no

1737
01:25:25,679 --> 01:25:28,560
default default replication factor of

1738
01:25:28,560 --> 01:25:32,640
azure DFS is three it's three it's

1739
01:25:32,640 --> 01:25:35,219
trying to save one copy locally and then

1740
01:25:35,219 --> 01:25:38,280
one copy across the rack across the Rock

1741
01:25:38,280 --> 01:25:40,040
and the

1742
01:25:40,040 --> 01:25:42,719
one copy in

1743
01:25:42,719 --> 01:25:45,540
like nearby in in the same note in the

1744
01:25:45,540 --> 01:25:50,000
same or same physical rack

1745
01:25:53,880 --> 01:25:56,960
Okay so

1746
01:26:01,139 --> 01:26:03,420
so why do we why do we leave abstraction

1747
01:26:03,420 --> 01:26:05,639
blocks in addition to file the reasons

1748
01:26:05,639 --> 01:26:07,739
the files can be larger than a single

1749
01:26:07,739 --> 01:26:09,179
disk it's still the same question with

1750
01:26:09,179 --> 01:26:11,520
the Unicode file system right blocks of

1751
01:26:11,520 --> 01:26:13,739
the fixed side easy to managing and

1752
01:26:13,739 --> 01:26:17,340
manipulate easy to replica case and do

1753
01:26:17,340 --> 01:26:19,980
more fire grade load balance more file

1754
01:26:19,980 --> 01:26:22,760
grade no balance

1755
01:26:23,940 --> 01:26:27,480
so the hdfs inside so let's skip that

1756
01:26:27,480 --> 01:26:30,120
this is Art building okay let's look at

1757
01:26:30,120 --> 01:26:32,580
this question why does hdfs choose such

1758
01:26:32,580 --> 01:26:35,820
a design for read okay

1759
01:26:35,820 --> 01:26:38,580
oh he's asking it's basically the read

1760
01:26:38,580 --> 01:26:41,880
and write performance of the hdfs it

1761
01:26:41,880 --> 01:26:44,460
basically asks you the design philosophy

1762
01:26:44,460 --> 01:26:47,340
of the read read and write

1763
01:26:47,340 --> 01:26:49,139
what's the difference between read and

1764
01:26:49,139 --> 01:26:51,380
write

1765
01:26:51,840 --> 01:26:54,860
read and write

1766
01:27:00,420 --> 01:27:03,480
but why it will infect your system

1767
01:27:03,480 --> 01:27:05,699
design of the file system why do

1768
01:27:05,699 --> 01:27:07,500
infected system design of the file

1769
01:27:07,500 --> 01:27:09,739
system

1770
01:27:11,280 --> 01:27:13,940
yes

1771
01:27:15,679 --> 01:27:18,600
no no not references

1772
01:27:18,600 --> 01:27:22,080
well here's the thing okay one one we

1773
01:27:22,080 --> 01:27:24,179
are both real file we can read it

1774
01:27:24,179 --> 01:27:26,400
together right can we write the file

1775
01:27:26,400 --> 01:27:27,420
together

1776
01:27:27,420 --> 01:27:29,460
no right that's the difference is

1777
01:27:29,460 --> 01:27:31,219
synchronization

1778
01:27:31,219 --> 01:27:34,320
overhead is the difference we cannot

1779
01:27:34,320 --> 01:27:37,020
write a file together right but we can

1780
01:27:37,020 --> 01:27:39,420
read a file together right if we do not

1781
01:27:39,420 --> 01:27:41,340
change the files the file will not be in

1782
01:27:41,340 --> 01:27:43,860
the critical section but if we need to

1783
01:27:43,860 --> 01:27:46,860
write a file write that make changes to

1784
01:27:46,860 --> 01:27:49,139
it we need to put it in a critical

1785
01:27:49,139 --> 01:27:50,820
section we need to settle

1786
01:27:50,820 --> 01:27:53,540
synchronization

1787
01:27:55,340 --> 01:27:57,900
whatever you want to use

1788
01:27:57,900 --> 01:28:00,679
yes Andrew

1789
01:28:05,040 --> 01:28:07,800
very good how do you upload the copies

1790
01:28:07,800 --> 01:28:10,199
there's two approaches one approach is

1791
01:28:10,199 --> 01:28:12,060
passive approach another approach is

1792
01:28:12,060 --> 01:28:14,580
active approach active approach you are

1793
01:28:14,580 --> 01:28:16,679
going to theoretically check

1794
01:28:16,679 --> 01:28:19,320
theoretically do check the fire if the

1795
01:28:19,320 --> 01:28:22,679
file got dirty if it is it's going to

1796
01:28:22,679 --> 01:28:25,440
change it to the replica so that is

1797
01:28:25,440 --> 01:28:27,900
active approach even it's not no one is

1798
01:28:27,900 --> 01:28:29,940
changed it it's still

1799
01:28:29,940 --> 01:28:33,239
it's still make the call like check it

1800
01:28:33,239 --> 01:28:35,340
periodically for every file so the

1801
01:28:35,340 --> 01:28:37,739
passive approach is that owning the file

1802
01:28:37,739 --> 01:28:39,780
is going to change then the name nodes

1803
01:28:39,780 --> 01:28:41,760
know that right at the beginning the

1804
01:28:41,760 --> 01:28:43,800
name node we know the name node

1805
01:28:43,800 --> 01:28:46,440
the name node knows Aries in the mapping

1806
01:28:46,440 --> 01:28:48,239
of The Blocking right the name node

1807
01:28:48,239 --> 01:28:50,580
knows that someone is changing that file

1808
01:28:50,580 --> 01:28:51,420
then

1809
01:28:51,420 --> 01:28:55,260
it's going to synchronize the copy in

1810
01:28:55,260 --> 01:28:57,480
different locations for that file for

1811
01:28:57,480 --> 01:29:00,860
the replica of the file okay

1812
01:29:01,739 --> 01:29:03,540
okay so this is basically what we have

1813
01:29:03,540 --> 01:29:07,199
learned so um in our last course we are

1814
01:29:07,199 --> 01:29:10,380
going to finish the file the distributed

1815
01:29:10,380 --> 01:29:12,120
file systems and we are going to talk

1816
01:29:12,120 --> 01:29:14,159
about another concept very important

1817
01:29:14,159 --> 01:29:16,380
concept called system virtualization

1818
01:29:16,380 --> 01:29:20,960
we're talking about virtual machines

1819
01:29:20,960 --> 01:29:23,760
then virtual machines VMware virtual

1820
01:29:23,760 --> 01:29:28,020
machines and uh containers

1821
01:29:28,020 --> 01:29:30,600
serverless you may heard of that service

1822
01:29:30,600 --> 01:29:33,480
is very popular concept

1823
01:29:33,480 --> 01:29:36,060
and then the next week we are going to

1824
01:29:36,060 --> 01:29:38,699
do the uh do the review okay we are

1825
01:29:38,699 --> 01:29:40,500
going to I'm planning to do two review

1826
01:29:40,500 --> 01:29:42,719
sessions the first review is that I'm

1827
01:29:42,719 --> 01:29:45,480
going to present this the second session

1828
01:29:45,480 --> 01:29:46,980
will be like you will ask me the

1829
01:29:46,980 --> 01:29:48,840
questions and I give you the answers

1830
01:29:48,840 --> 01:29:52,280
okay so that's the plan

1831
01:29:57,540 --> 01:30:00,080
foreign

