1
00:00:00,000 --> 00:00:03,240
released this week last week we will

2
00:00:03,240 --> 00:00:06,720
also have one assignments

3
00:00:06,720 --> 00:00:09,800
released I believe today or tomorrow so

4
00:00:09,800 --> 00:00:13,019
for for the first projection of first

5
00:00:13,019 --> 00:00:14,700
assignments

6
00:00:14,700 --> 00:00:17,940
um you have one week to finish and you

7
00:00:17,940 --> 00:00:20,520
need to do it individually so do not

8
00:00:20,520 --> 00:00:22,199
copy

9
00:00:22,199 --> 00:00:27,300
your classmates or others answers if for

10
00:00:27,300 --> 00:00:29,160
the especially for the homework

11
00:00:29,160 --> 00:00:31,679
assignments I hope that you can you you

12
00:00:31,679 --> 00:00:35,160
are free to use any resources

13
00:00:35,160 --> 00:00:38,219
like in the website Google it but you

14
00:00:38,219 --> 00:00:40,559
need to you need to mention that where

15
00:00:40,559 --> 00:00:43,020
you got this answer and write down your

16
00:00:43,020 --> 00:00:45,600
own understanding okay if we find out

17
00:00:45,600 --> 00:00:46,980
that

18
00:00:46,980 --> 00:00:49,559
um you write down the exactly the same

19
00:00:49,559 --> 00:00:50,879
answers

20
00:00:50,879 --> 00:00:53,219
with your classmates or with some open

21
00:00:53,219 --> 00:00:56,340
source answers that we know then you you

22
00:00:56,340 --> 00:01:00,480
may you may be risk at receiving no

23
00:01:00,480 --> 00:01:03,359
points for that answer so I hope we are

24
00:01:03,359 --> 00:01:04,920
clear about that

25
00:01:04,920 --> 00:01:06,920
um

26
00:01:07,140 --> 00:01:10,020
and for the projects that we store are

27
00:01:10,020 --> 00:01:13,799
same lure you you cannot

28
00:01:13,799 --> 00:01:16,799
collaborate with anyone in the classroom

29
00:01:16,799 --> 00:01:19,140
to finish their projects it needs to be

30
00:01:19,140 --> 00:01:22,520
done individually

31
00:01:23,880 --> 00:01:28,259
and my greater I ask my graders to use

32
00:01:28,259 --> 00:01:30,960
some progress on software well to check

33
00:01:30,960 --> 00:01:33,540
so if I found out that

34
00:01:33,540 --> 00:01:34,259
um

35
00:01:34,259 --> 00:01:38,340
I I will talk to you and so for my

36
00:01:38,340 --> 00:01:40,619
previous experiments like every class

37
00:01:40,619 --> 00:01:43,820
that I have

38
00:01:44,360 --> 00:01:46,979
almost every class there are around like

39
00:01:46,979 --> 00:01:49,979
10 more with more students who actually

40
00:01:49,979 --> 00:01:53,159
didn't pass and it's not because they

41
00:01:53,159 --> 00:01:53,939
are

42
00:01:53,939 --> 00:01:56,220
not smart oh it's not because they are

43
00:01:56,220 --> 00:01:59,299
not hard working and the most of them

44
00:01:59,299 --> 00:02:02,100
didn't pass because they

45
00:02:02,100 --> 00:02:05,159
they cheat okay so you are supposed to

46
00:02:05,159 --> 00:02:08,038
finish it individually even you didn't

47
00:02:08,038 --> 00:02:11,160
do it grades we have many ways to help

48
00:02:11,160 --> 00:02:12,959
you improve your grade

49
00:02:12,959 --> 00:02:16,800
okay but it's it's not good to copy the

50
00:02:16,800 --> 00:02:21,739
answers from anywhere else okay

51
00:02:22,440 --> 00:02:24,900
so starting from this week we are going

52
00:02:24,900 --> 00:02:27,360
to move to the our

53
00:02:27,360 --> 00:02:30,720
uh each chapter of the textbook I have

54
00:02:30,720 --> 00:02:33,480
the textbook Solutions but I cannot

55
00:02:33,480 --> 00:02:36,000
unfortunately I cannot upload it in the

56
00:02:36,000 --> 00:02:38,400
canvas and then I'll share it with you

57
00:02:38,400 --> 00:02:40,319
because there's some copyright problem

58
00:02:40,319 --> 00:02:42,900
you have to buy the book to get a

59
00:02:42,900 --> 00:02:45,239
solution menu so I give I give the

60
00:02:45,239 --> 00:02:48,060
solution menu to my ta so if you have

61
00:02:48,060 --> 00:02:49,739
any for example when you read the

62
00:02:49,739 --> 00:02:52,080
textbook and you have you will not know

63
00:02:52,080 --> 00:02:54,720
some uh questions answers so feel free

64
00:02:54,720 --> 00:02:58,560
to uh ping my ta will come to the TA

65
00:02:58,560 --> 00:03:01,379
hours and then we we can share that with

66
00:03:01,379 --> 00:03:03,920
you okay

67
00:03:05,840 --> 00:03:09,120
okay so uh so starting this week we are

68
00:03:09,120 --> 00:03:13,099
going to learn process and threat

69
00:03:16,220 --> 00:03:19,379
so the most Central Concept in any

70
00:03:19,379 --> 00:03:22,200
operating system is process a process is

71
00:03:22,200 --> 00:03:26,420
an abstraction of a running program

72
00:03:27,000 --> 00:03:29,879
everything everything else is just a

73
00:03:29,879 --> 00:03:32,819
strong this concept

74
00:03:32,819 --> 00:03:35,280
well you can think of that

75
00:03:35,280 --> 00:03:37,200
um process is

76
00:03:37,200 --> 00:03:39,420
so everything

77
00:03:39,420 --> 00:03:43,019
in the OS if they needs to run then they

78
00:03:43,019 --> 00:03:46,080
have to run it with the process okay so

79
00:03:46,080 --> 00:03:50,299
it's an abstraction of a running program

80
00:03:52,440 --> 00:03:55,640
so um

81
00:03:57,180 --> 00:03:59,340
so for example if you're writing some

82
00:03:59,340 --> 00:04:02,819
code let's say it's like a plus b plus C

83
00:04:02,819 --> 00:04:05,819
you give a value and then be a value and

84
00:04:05,819 --> 00:04:07,799
see a value and you find out the answer

85
00:04:07,799 --> 00:04:10,739
of a plus b plus C this is just a

86
00:04:10,739 --> 00:04:13,980
program only when you loaded that in

87
00:04:13,980 --> 00:04:17,399
memory and start running that then that

88
00:04:17,399 --> 00:04:18,899
programs become

89
00:04:18,899 --> 00:04:21,660
process okay so let's take a look at

90
00:04:21,660 --> 00:04:24,660
what exactly is a process

91
00:04:24,660 --> 00:04:27,660
so process is an instance of program

92
00:04:27,660 --> 00:04:30,720
it has registers variables and a program

93
00:04:30,720 --> 00:04:33,380
counter

94
00:04:33,660 --> 00:04:36,240
it has a program inputs output and the

95
00:04:36,240 --> 00:04:37,919
states

96
00:04:37,919 --> 00:04:41,000
okay so and

97
00:04:42,360 --> 00:04:45,600
so first is an instance of a program so

98
00:04:45,600 --> 00:04:48,660
let's go through that together okay so

99
00:04:48,660 --> 00:04:50,400
what is a program program is just your

100
00:04:50,400 --> 00:04:52,680
code you write in some code so this is

101
00:04:52,680 --> 00:04:55,500
the code and then with registers

102
00:04:55,500 --> 00:04:57,840
variables and program counters so what's

103
00:04:57,840 --> 00:04:58,680
that

104
00:04:58,680 --> 00:05:01,639
what is that

105
00:05:01,759 --> 00:05:06,560
registers valuables or program counters

106
00:05:51,660 --> 00:05:54,600
so uh so here's the concept of process

107
00:05:54,600 --> 00:05:56,820
okay process

108
00:05:56,820 --> 00:05:59,100
so firstly you need to understand the

109
00:05:59,100 --> 00:06:02,460
process it's not just code it is a

110
00:06:02,460 --> 00:06:04,580
running program it's a running program

111
00:06:04,580 --> 00:06:09,780
but to to make a program run in your

112
00:06:09,780 --> 00:06:11,280
computer

113
00:06:11,280 --> 00:06:14,699
you first need to load that into the

114
00:06:14,699 --> 00:06:16,560
memory right you need to load that into

115
00:06:16,560 --> 00:06:19,039
the memory

116
00:06:19,620 --> 00:06:22,199
so let's see this is a memory this is

117
00:06:22,199 --> 00:06:25,139
memory and we discussed starting our

118
00:06:25,139 --> 00:06:27,840
introduction memory for every process

119
00:06:27,840 --> 00:06:30,539
for every program when it's when we load

120
00:06:30,539 --> 00:06:34,139
that into the memory we allocate

121
00:06:34,139 --> 00:06:36,600
each program uh

122
00:06:36,600 --> 00:06:39,960
independent or just space to them so

123
00:06:39,960 --> 00:06:41,100
Independence

124
00:06:41,100 --> 00:06:43,560
are just paste you can think of that

125
00:06:43,560 --> 00:06:46,919
this is the location of where they

126
00:06:46,919 --> 00:06:50,100
should be where they should reside in

127
00:06:50,100 --> 00:06:54,139
the memory so this is memory

128
00:06:54,180 --> 00:06:56,520
we have memory memory is divided into

129
00:06:56,520 --> 00:06:59,400
many pieces and we call this is pages

130
00:06:59,400 --> 00:07:02,759
okay let's say we give these pages to

131
00:07:02,759 --> 00:07:04,979
this process so we loaded that the

132
00:07:04,979 --> 00:07:07,800
program into the memory right into the

133
00:07:07,800 --> 00:07:11,160
memory and then who are going to access

134
00:07:11,160 --> 00:07:13,259
to it who are going to access it our

135
00:07:13,259 --> 00:07:15,720
computational components of the

136
00:07:15,720 --> 00:07:17,880
operating system right who are the

137
00:07:17,880 --> 00:07:20,160
computational components CPU is the

138
00:07:20,160 --> 00:07:22,560
computational components

139
00:07:22,560 --> 00:07:25,680
recipe with our compilation components

140
00:07:25,680 --> 00:07:28,080
so it has several

141
00:07:28,080 --> 00:07:31,199
several a very small tiny computation

142
00:07:31,199 --> 00:07:35,280
units like we decodes the we decode the

143
00:07:35,280 --> 00:07:38,220
code right we executed that right and

144
00:07:38,220 --> 00:07:39,960
then we talk about pipeline in our

145
00:07:39,960 --> 00:07:42,960
introduction so CPU is going to load

146
00:07:42,960 --> 00:07:45,060
that going to

147
00:07:45,060 --> 00:07:48,300
going to run it then when you when CPU

148
00:07:48,300 --> 00:07:51,000
is running the process if you CPU has

149
00:07:51,000 --> 00:07:53,340
some less ACP CPU is a computational

150
00:07:53,340 --> 00:07:55,860
components right it has some this is the

151
00:07:55,860 --> 00:07:57,840
computational components and also CPU

152
00:07:57,840 --> 00:07:59,400
has some

153
00:07:59,400 --> 00:08:03,620
caches like we call it a register

154
00:08:03,960 --> 00:08:08,660
register so it has the register

155
00:08:10,919 --> 00:08:12,840
program counter program counter is

156
00:08:12,840 --> 00:08:16,620
actually a special register so when CPU

157
00:08:16,620 --> 00:08:20,220
is running this program will load that

158
00:08:20,220 --> 00:08:23,400
into the memory right it's still that it

159
00:08:23,400 --> 00:08:25,139
is still there we have a lot of years

160
00:08:25,139 --> 00:08:28,919
executed so to excuse the program if you

161
00:08:28,919 --> 00:08:31,800
if you take the compiler course or you

162
00:08:31,800 --> 00:08:33,659
might be familiar with that so we need

163
00:08:33,659 --> 00:08:35,820
to load that right they have some code

164
00:08:35,820 --> 00:08:39,779
like junk right the jump

165
00:08:39,779 --> 00:08:42,539
all right they loaded that taken that

166
00:08:42,539 --> 00:08:45,420
and read that into the register and also

167
00:08:45,420 --> 00:08:47,459
the program counter going to read this

168
00:08:47,459 --> 00:08:48,300
code

169
00:08:48,300 --> 00:08:52,380
so a process will include a process or

170
00:08:52,380 --> 00:08:53,640
includes

171
00:08:53,640 --> 00:08:56,300
is everything okay this everything

172
00:08:56,300 --> 00:09:00,240
everything so this together we call it a

173
00:09:00,240 --> 00:09:02,240
process that's why process

174
00:09:02,240 --> 00:09:03,899
includes the

175
00:09:03,899 --> 00:09:07,200
program with the registers with the

176
00:09:07,200 --> 00:09:09,839
program counters and with its valuables

177
00:09:09,839 --> 00:09:13,580
so it has some valuables

178
00:09:13,980 --> 00:09:18,380
and also it has

179
00:09:19,560 --> 00:09:21,839
inputs

180
00:09:21,839 --> 00:09:24,660
and outputs

181
00:09:24,660 --> 00:09:28,080
do not eat things in the class okay

182
00:09:28,080 --> 00:09:29,300
okay

183
00:09:29,300 --> 00:09:31,620
let's uh

184
00:09:31,620 --> 00:09:34,260
so let's continue so we have the inputs

185
00:09:34,260 --> 00:09:37,080
and outputs okay

186
00:09:37,080 --> 00:09:40,440
so what else what else

187
00:09:40,440 --> 00:09:43,220
state

188
00:09:43,560 --> 00:09:46,260
so what is state

189
00:09:46,260 --> 00:09:50,060
any student know what is state

190
00:09:56,899 --> 00:09:59,700
uh is actually different this is what we

191
00:09:59,700 --> 00:10:01,980
are going to learn we are going to learn

192
00:10:01,980 --> 00:10:04,680
it's actually different but it's it is

193
00:10:04,680 --> 00:10:09,180
slightly closed okay so States

194
00:10:09,180 --> 00:10:11,160
you can think of that

195
00:10:11,160 --> 00:10:13,160
um

196
00:10:13,860 --> 00:10:16,620
so this is a running running process

197
00:10:16,620 --> 00:10:19,680
right this is running process but it

198
00:10:19,680 --> 00:10:21,420
cannot always run

199
00:10:21,420 --> 00:10:24,240
it cannot always runs why because

200
00:10:24,240 --> 00:10:27,120
we we know that CPU is let's say let's

201
00:10:27,120 --> 00:10:30,600
say CPU has only one coin so CPU can

202
00:10:30,600 --> 00:10:34,920
only run one program at a time right so

203
00:10:34,920 --> 00:10:38,160
you cannot always run

204
00:10:38,160 --> 00:10:40,920
then the state is relating to whether it

205
00:10:40,920 --> 00:10:42,779
is running or whether it is not running

206
00:10:42,779 --> 00:10:44,820
that is what we are going to learn later

207
00:10:44,820 --> 00:10:47,459
so here you need to take away here is

208
00:10:47,459 --> 00:10:50,640
that process so what anyone else we will

209
00:10:50,640 --> 00:10:52,440
interview questions wanted to ask you

210
00:10:52,440 --> 00:10:54,480
what is the process do not think that

211
00:10:54,480 --> 00:10:56,880
process is just your program think of

212
00:10:56,880 --> 00:10:58,680
that Pro you you have a program right

213
00:10:58,680 --> 00:11:01,320
your program has input outputs valuables

214
00:11:01,320 --> 00:11:03,779
in your code that all together with the

215
00:11:03,779 --> 00:11:07,079
program and when it is running the CPU

216
00:11:07,079 --> 00:11:09,060
needs to load that the memory needs we

217
00:11:09,060 --> 00:11:10,800
need to load that into memory and then

218
00:11:10,800 --> 00:11:14,700
CPU needs to use some registers to read

219
00:11:14,700 --> 00:11:17,880
this code so everything together

220
00:11:17,880 --> 00:11:20,700
we quite up we quite a

221
00:11:20,700 --> 00:11:23,899
process okay

222
00:11:30,420 --> 00:11:33,200
so the second thing is about

223
00:11:33,200 --> 00:11:36,180
multi-programming this is very easy to

224
00:11:36,180 --> 00:11:38,279
understand so multi-programming means

225
00:11:38,279 --> 00:11:40,399
that

226
00:11:42,480 --> 00:11:46,680
we have we have at one time we have

227
00:11:46,680 --> 00:11:52,560
many importers running in on top of OS

228
00:11:52,560 --> 00:11:55,620
if if you look at this picture this

229
00:11:55,620 --> 00:11:56,700
picture

230
00:11:56,700 --> 00:11:59,459
this is the first picture is the

231
00:11:59,459 --> 00:12:01,079
um

232
00:12:01,079 --> 00:12:04,980
how we how we see uh the pro the four

233
00:12:04,980 --> 00:12:07,800
programs in memory so we can see that

234
00:12:07,800 --> 00:12:10,200
here the memory is large right

235
00:12:10,200 --> 00:12:12,120
the memory is very large right

236
00:12:12,120 --> 00:12:14,160
then we can see that each you can see

237
00:12:14,160 --> 00:12:17,700
each program they have there

238
00:12:17,700 --> 00:12:20,820
Independence address phase right you can

239
00:12:20,820 --> 00:12:23,579
see that so and then

240
00:12:23,579 --> 00:12:25,860
and then how the pro how the context

241
00:12:25,860 --> 00:12:28,519
switch happens

242
00:12:29,940 --> 00:12:32,820
so we have the program counter program

243
00:12:32,820 --> 00:12:36,000
program countries of register inside of

244
00:12:36,000 --> 00:12:39,180
the CPU so CPU using the program counter

245
00:12:39,180 --> 00:12:40,579
to design

246
00:12:40,579 --> 00:12:43,560
which line of the code to read which

247
00:12:43,560 --> 00:12:45,420
line of the code to read so they switch

248
00:12:45,420 --> 00:12:47,940
for this program process and then the

249
00:12:47,940 --> 00:12:49,500
second one the third one then the first

250
00:12:49,500 --> 00:12:51,899
one and then they switch there's there's

251
00:12:51,899 --> 00:12:54,959
many scheduling algorithms relating to

252
00:12:54,959 --> 00:12:57,600
that we are going to learn that in later

253
00:12:57,600 --> 00:13:00,240
slides but here the takeaway here is

254
00:13:00,240 --> 00:13:03,740
that you see if you see this

255
00:13:04,860 --> 00:13:06,959
we can see that

256
00:13:06,959 --> 00:13:09,240
this is a space sharing approach

257
00:13:09,240 --> 00:13:11,519
difference process they are concurrent

258
00:13:11,519 --> 00:13:14,940
running on top of the OS and they are

259
00:13:14,940 --> 00:13:18,360
inside of the memory at the same time at

260
00:13:18,360 --> 00:13:20,700
the same time now let's talk let's take

261
00:13:20,700 --> 00:13:23,579
a look at C okay the slice C

262
00:13:23,579 --> 00:13:26,339
so how the CPU is gathering

263
00:13:26,339 --> 00:13:29,519
between these four program how

264
00:13:29,519 --> 00:13:31,860
distributes scheduling before between

265
00:13:31,860 --> 00:13:35,399
this so this is why I say that

266
00:13:35,399 --> 00:13:39,060
if we just for the rest of the this book

267
00:13:39,060 --> 00:13:41,940
okay we only seen CPU with just one coin

268
00:13:41,940 --> 00:13:44,100
CPU we do not think it's a like multiple

269
00:13:44,100 --> 00:13:46,320
coins CPU we do not think of that it

270
00:13:46,320 --> 00:13:48,839
also consists of GPU now it's just a CPU

271
00:13:48,839 --> 00:13:50,579
with one coin okay

272
00:13:50,579 --> 00:13:54,300
so you see this view what I did as the

273
00:13:54,300 --> 00:13:57,720
time goes as time goes by you see he

274
00:13:57,720 --> 00:14:00,839
kept owning around one program at a time

275
00:14:00,839 --> 00:14:03,660
right one program one process at a time

276
00:14:03,660 --> 00:14:07,560
at this time it runs a and then switch

277
00:14:07,560 --> 00:14:10,620
to another time it runs B and runs C and

278
00:14:10,620 --> 00:14:13,220
run stick

279
00:14:14,339 --> 00:14:17,100
so and you still don't know like

280
00:14:17,100 --> 00:14:20,100
CPU is using this kind of sequence to

281
00:14:20,100 --> 00:14:22,740
run different program why we have a

282
00:14:22,740 --> 00:14:26,220
feeling why we do not why

283
00:14:26,220 --> 00:14:30,139
we can still when we are using

284
00:14:30,360 --> 00:14:32,760
when we are using our laptop we we still

285
00:14:32,760 --> 00:14:34,380
have the feeling that they are

286
00:14:34,380 --> 00:14:36,899
concurrent running like we I can easily

287
00:14:36,899 --> 00:14:40,980
open up 10 office right and 10

288
00:14:40,980 --> 00:14:44,100
of what office documents right I can

289
00:14:44,100 --> 00:14:48,360
easily open 10 and when I open this turn

290
00:14:48,360 --> 00:14:51,660
I can easily write them together and I

291
00:14:51,660 --> 00:14:54,300
can listen to music I can watch video

292
00:14:54,300 --> 00:14:57,600
I'm gonna run many I do not have the

293
00:14:57,600 --> 00:14:59,699
feeling that the CPU is switching

294
00:14:59,699 --> 00:15:03,500
between this do you know why

295
00:15:09,839 --> 00:15:13,139
why why we have no feeling that that CPU

296
00:15:13,139 --> 00:15:15,720
is switching is running one program at

297
00:15:15,720 --> 00:15:19,100
one time yes

298
00:15:22,560 --> 00:15:23,839
yes

299
00:15:23,839 --> 00:15:27,060
each each of the time slides is in the

300
00:15:27,060 --> 00:15:29,220
order of level seconds it's not many

301
00:15:29,220 --> 00:15:32,040
seconds it's not it's not many seconds

302
00:15:32,040 --> 00:15:34,740
it's not seconds it's the nanoseconds

303
00:15:34,740 --> 00:15:37,740
it's in the nanoseconds so it happens

304
00:15:37,740 --> 00:15:41,459
very very fast so um we remember that

305
00:15:41,459 --> 00:15:44,820
when we purchase when you are going to I

306
00:15:44,820 --> 00:15:46,680
do not know who have experiments with

307
00:15:46,680 --> 00:15:48,839
building a game PC when you're building

308
00:15:48,839 --> 00:15:51,000
a game PC you always think of okay I

309
00:15:51,000 --> 00:15:54,060
want a very high speed CPU right so that

310
00:15:54,060 --> 00:15:56,639
is the speed this high speed is really

311
00:15:56,639 --> 00:15:59,399
into this relating to this how they can

312
00:15:59,399 --> 00:16:02,220
do the contact switch okay

313
00:16:02,220 --> 00:16:04,320
so this is the concept of the

314
00:16:04,320 --> 00:16:07,320
multi-programming

315
00:16:11,000 --> 00:16:12,600
uh

316
00:16:12,600 --> 00:16:14,880
so

317
00:16:14,880 --> 00:16:17,279
so operating system needs some way to

318
00:16:17,279 --> 00:16:20,040
create process in very simple system or

319
00:16:20,040 --> 00:16:23,180
in system design for running only one

320
00:16:23,180 --> 00:16:26,459
single application it may be possible to

321
00:16:26,459 --> 00:16:28,560
have one all the processes that were

322
00:16:28,560 --> 00:16:31,680
ever leaded to present one system comes

323
00:16:31,680 --> 00:16:33,839
up so what happens for the process

324
00:16:33,839 --> 00:16:35,160
creation

325
00:16:35,160 --> 00:16:37,160
um

326
00:16:39,540 --> 00:16:43,380
when we when we here

327
00:16:43,380 --> 00:16:47,220
when we create a process one will put

328
00:16:47,220 --> 00:16:49,019
the system right when you boost the

329
00:16:49,019 --> 00:16:50,779
system

330
00:16:50,779 --> 00:16:54,360
so what is the process

331
00:16:54,360 --> 00:16:56,759
that is the first loaded in memory when

332
00:16:56,759 --> 00:16:59,880
you put OS

333
00:16:59,880 --> 00:17:02,279
there's a boot process right there's a

334
00:17:02,279 --> 00:17:04,880
boot process

335
00:17:04,919 --> 00:17:07,619
you may have data experiments like you

336
00:17:07,619 --> 00:17:10,679
know when it happens for the blue screen

337
00:17:10,679 --> 00:17:13,439
right so you always find out so where is

338
00:17:13,439 --> 00:17:15,780
the how it is loaded

339
00:17:15,780 --> 00:17:17,819
right you can you can brush some

340
00:17:17,819 --> 00:17:20,400
interrupts interrupts single to the

341
00:17:20,400 --> 00:17:22,740
hardware the hardware pick it up it lets

342
00:17:22,740 --> 00:17:25,799
you to choose how to load this OS

343
00:17:25,799 --> 00:17:28,319
so that is the one system initialization

344
00:17:28,319 --> 00:17:30,179
or process will be created

345
00:17:30,179 --> 00:17:33,559
and what else

346
00:17:36,120 --> 00:17:38,820
a process can be also created by a

347
00:17:38,820 --> 00:17:40,620
running process okay by a running

348
00:17:40,620 --> 00:17:43,100
process

349
00:17:45,299 --> 00:17:48,000
for example a parent process can create

350
00:17:48,000 --> 00:17:50,700
a child process during trans you are

351
00:17:50,700 --> 00:17:53,880
going to use that in your in your

352
00:17:53,880 --> 00:17:56,360
projects

353
00:17:56,580 --> 00:17:59,700
a user request to create a new process a

354
00:17:59,700 --> 00:18:01,799
user request to create support for new

355
00:18:01,799 --> 00:18:06,020
process that is an interactive command

356
00:18:06,059 --> 00:18:09,660
an initialization or batch job

357
00:18:09,660 --> 00:18:12,720
so there are many examples of a process

358
00:18:12,720 --> 00:18:13,980
creation

359
00:18:13,980 --> 00:18:15,980
um

360
00:18:16,559 --> 00:18:19,559
so how to terminate a process so process

361
00:18:19,559 --> 00:18:21,539
can be terminated here the takeaway is

362
00:18:21,539 --> 00:18:24,240
that process can be terminated in our

363
00:18:24,240 --> 00:18:27,000
volunteer way or land voluntary in

364
00:18:27,000 --> 00:18:29,700
warranty array so Loma exists or Arrow

365
00:18:29,700 --> 00:18:33,179
exists they are all volunteer

366
00:18:33,179 --> 00:18:36,299
you you catch up by exception this is

367
00:18:36,299 --> 00:18:38,580
still a volunteer

368
00:18:38,580 --> 00:18:41,460
right but if it is something like

369
00:18:41,460 --> 00:18:43,679
segmentation forward and then it is

370
00:18:43,679 --> 00:18:45,780
existed then there is in warranty okay

371
00:18:45,780 --> 00:18:48,480
it's or it's killed by another process

372
00:18:48,480 --> 00:18:50,340
for example we found out the system is

373
00:18:50,340 --> 00:18:54,480
stuck so we just brush some

374
00:18:54,480 --> 00:18:57,360
um commands to interrupt it right then

375
00:18:57,360 --> 00:19:00,600
that is the key by another process

376
00:19:00,600 --> 00:19:04,140
okay so now it comes to a first key

377
00:19:04,140 --> 00:19:06,840
Concept in the process chapter is the

378
00:19:06,840 --> 00:19:09,500
process States

379
00:19:20,000 --> 00:19:23,480
so um

380
00:19:27,720 --> 00:19:30,299
so process has in this different

381
00:19:30,299 --> 00:19:33,419
textbooks have differences so

382
00:19:33,419 --> 00:19:35,760
um explanations for these process States

383
00:19:35,760 --> 00:19:38,820
I I see that one textbook saying that

384
00:19:38,820 --> 00:19:40,559
there's five states another textbook

385
00:19:40,559 --> 00:19:43,080
saying that the four states uh this type

386
00:19:43,080 --> 00:19:44,760
of textbooks saying that there's only

387
00:19:44,760 --> 00:19:47,299
three states

388
00:19:47,460 --> 00:19:50,460
and for modern operating systems May uh

389
00:19:50,460 --> 00:19:53,400
have I believe is five states but these

390
00:19:53,400 --> 00:19:55,799
three states are the

391
00:19:55,799 --> 00:19:58,500
um most important states of a process

392
00:19:58,500 --> 00:20:01,140
the other the other two actual States

393
00:20:01,140 --> 00:20:04,260
they are just the new added States but

394
00:20:04,260 --> 00:20:06,059
they are related to these three states

395
00:20:06,059 --> 00:20:08,220
so you need what you need to remember is

396
00:20:08,220 --> 00:20:10,380
this three states so let's take a look

397
00:20:10,380 --> 00:20:13,440
at what these three stages and how they

398
00:20:13,440 --> 00:20:16,740
transfer between each other so here this

399
00:20:16,740 --> 00:20:19,860
concept this picture I hope everyone can

400
00:20:19,860 --> 00:20:21,360
memorize it

401
00:20:21,360 --> 00:20:24,000
even you cannot understand it for now

402
00:20:24,000 --> 00:20:27,059
but you need to memorize it we are going

403
00:20:27,059 --> 00:20:29,760
to test that in the exam this is very

404
00:20:29,760 --> 00:20:34,220
important okay so the process States

405
00:20:36,179 --> 00:20:38,880
we have three states running blocked and

406
00:20:38,880 --> 00:20:41,880
ready so let's look at this the first

407
00:20:41,880 --> 00:20:45,240
one running what is the running States

408
00:20:45,240 --> 00:20:47,400
when our processes

409
00:20:47,400 --> 00:20:49,860
run in the it is in the running stage

410
00:20:49,860 --> 00:20:52,580
right

411
00:20:53,280 --> 00:20:55,620
so the challenging here is that the

412
00:20:55,620 --> 00:20:57,720
differences between block States and the

413
00:20:57,720 --> 00:21:01,520
ready States and the ready States

414
00:21:02,400 --> 00:21:06,679
so what is the ready stage

415
00:21:07,559 --> 00:21:12,000
ready stage ready stage is

416
00:21:12,000 --> 00:21:15,480
is some process that is runable is ready

417
00:21:15,480 --> 00:21:17,960
to run it's ready to run

418
00:21:17,960 --> 00:21:22,980
however however it is not his turn to

419
00:21:22,980 --> 00:21:25,200
run yet

420
00:21:25,200 --> 00:21:29,280
CPU has not yet scheduling it later I

421
00:21:29,280 --> 00:21:31,620
will draw a picture to show that okay so

422
00:21:31,620 --> 00:21:33,900
that is the ready States ready States

423
00:21:33,900 --> 00:21:36,120
means that this process

424
00:21:36,120 --> 00:21:40,500
okay to discuss that let's first uh

425
00:21:40,500 --> 00:21:44,039
let's re remember again what is the

426
00:21:44,039 --> 00:21:46,200
what is the process process is a running

427
00:21:46,200 --> 00:21:48,900
program right and it has

428
00:21:48,900 --> 00:21:51,960
input outputs the code and it also has

429
00:21:51,960 --> 00:21:55,100
the register value the variables

430
00:21:55,100 --> 00:21:59,159
and it says right so

431
00:21:59,159 --> 00:22:02,220
what is this means that the process has

432
00:22:02,220 --> 00:22:06,120
everything available it has its inputs

433
00:22:06,120 --> 00:22:08,520
available it has its code available

434
00:22:08,520 --> 00:22:11,100
everything is already loaded at in the

435
00:22:11,100 --> 00:22:13,020
memory

436
00:22:13,020 --> 00:22:15,299
what he's missing what he's missing the

437
00:22:15,299 --> 00:22:20,159
process just do not yes has the CPU turn

438
00:22:20,159 --> 00:22:22,980
Okay so that is means it's in the ready

439
00:22:22,980 --> 00:22:25,460
stage

440
00:22:25,919 --> 00:22:28,260
what is the block space what is the

441
00:22:28,260 --> 00:22:29,760
block States

442
00:22:29,760 --> 00:22:33,419
block States means that this process is

443
00:22:33,419 --> 00:22:37,140
not really as it has it needs to wait

444
00:22:37,140 --> 00:22:40,020
it is unable to run these two weights

445
00:22:40,020 --> 00:22:44,460
until some external events happens which

446
00:22:44,460 --> 00:22:49,200
is usually a for example example of that

447
00:22:49,200 --> 00:22:52,260
when we are um

448
00:22:52,260 --> 00:22:55,260
example is that while a process is

449
00:22:55,260 --> 00:23:00,240
waiting for Io input IO inputs let's say

450
00:23:00,240 --> 00:23:02,820
it's waiting for users interactive

451
00:23:02,820 --> 00:23:05,820
operation of input sum operation like

452
00:23:05,820 --> 00:23:08,340
brush the keyboard so the process can

453
00:23:08,340 --> 00:23:10,559
run then it is in a block state

454
00:23:10,559 --> 00:23:13,640
so um

455
00:23:14,159 --> 00:23:17,900
let's take a look at this okay

456
00:23:58,880 --> 00:24:01,500
okay this is a CPU this is your

457
00:24:01,500 --> 00:24:03,900
computational components okay there's a

458
00:24:03,900 --> 00:24:07,020
queue inside of CPU there's a queue

459
00:24:07,020 --> 00:24:09,299
okay the queue will actually saying the

460
00:24:09,299 --> 00:24:11,220
queue the queue is the process process

461
00:24:11,220 --> 00:24:15,000
are in the queue okay and then

462
00:24:15,000 --> 00:24:19,220
there's a process running okay

463
00:24:23,400 --> 00:24:27,419
so the row means that CPU is switching

464
00:24:27,419 --> 00:24:30,240
switching the water order between this

465
00:24:30,240 --> 00:24:34,980
process let's say this is P1 P2 P3 P4 P5

466
00:24:34,980 --> 00:24:37,340
p

467
00:24:42,120 --> 00:24:45,179
there's some four

468
00:24:45,179 --> 00:24:47,720
okay

469
00:24:54,840 --> 00:24:59,059
okay let's look at this

470
00:25:01,940 --> 00:25:06,980
here we have let's say we have six

471
00:25:07,380 --> 00:25:09,840
this is your CPU okay this is your CPU

472
00:25:09,840 --> 00:25:12,480
okay we have one two three four five six

473
00:25:12,480 --> 00:25:15,000
we have six programs are conclude

474
00:25:15,000 --> 00:25:17,880
running and we call it a process right

475
00:25:17,880 --> 00:25:21,419
we call it a process now they are in the

476
00:25:21,419 --> 00:25:23,400
running stage right there in the running

477
00:25:23,400 --> 00:25:26,580
stage they can come running now CPU is

478
00:25:26,580 --> 00:25:29,299
doing the part multi-programming

479
00:25:29,299 --> 00:25:32,159
multi-programming tool do some time

480
00:25:32,159 --> 00:25:35,580
sharing between this process like each

481
00:25:35,580 --> 00:25:37,799
process can get some level seconds to

482
00:25:37,799 --> 00:25:38,880
run

483
00:25:38,880 --> 00:25:40,860
the CPU is switching because if you can

484
00:25:40,860 --> 00:25:42,960
only run one process at one time so it's

485
00:25:42,960 --> 00:25:45,120
let's say switch to this is switch to

486
00:25:45,120 --> 00:25:47,220
that the next time switch to this next

487
00:25:47,220 --> 00:25:49,860
time but they'll still

488
00:25:49,860 --> 00:25:52,200
they are all in the running state so

489
00:25:52,200 --> 00:25:55,460
that is the running stage

490
00:25:57,200 --> 00:26:02,640
now here p7 joins the system p7 joins

491
00:26:02,640 --> 00:26:06,419
systems unfortunately unfortunately

492
00:26:06,419 --> 00:26:09,779
CPU can only can only hold

493
00:26:09,779 --> 00:26:13,140
six process at one time counts can hold

494
00:26:13,140 --> 00:26:16,980
six process so what about p7 will do p7

495
00:26:16,980 --> 00:26:20,580
will go Will Wait into the queue okay it

496
00:26:20,580 --> 00:26:23,279
will comes to here it will wait to the

497
00:26:23,279 --> 00:26:26,720
queue it will wait here

498
00:26:27,179 --> 00:26:29,039
p7

499
00:26:29,039 --> 00:26:31,980
p8 P9 P10

500
00:26:31,980 --> 00:26:35,000
they are waiting here

501
00:26:35,460 --> 00:26:38,580
but they have their inputs

502
00:26:38,580 --> 00:26:40,020
data

503
00:26:40,020 --> 00:26:41,900
outputs they have everything available

504
00:26:41,900 --> 00:26:46,140
they just need CPU scheduling order then

505
00:26:46,140 --> 00:26:49,380
they can start to run and so they are in

506
00:26:49,380 --> 00:26:52,320
which states they are in ready States

507
00:26:52,320 --> 00:26:55,820
right there in the ready States

508
00:26:56,460 --> 00:26:59,460
can they come can they switch from the

509
00:26:59,460 --> 00:27:02,100
ready states to running States

510
00:27:02,100 --> 00:27:04,860
yes they can right they can why why they

511
00:27:04,860 --> 00:27:07,679
can because why we know CPU is doing a

512
00:27:07,679 --> 00:27:10,260
fair sharing Fair sharing so like if

513
00:27:10,260 --> 00:27:13,559
let's say CPU is doing some short is the

514
00:27:13,559 --> 00:27:15,900
remaining time left scattering algorithm

515
00:27:15,900 --> 00:27:20,460
and the CPU is find out okay P1

516
00:27:20,460 --> 00:27:23,640
P1 still has a lot of time left but the

517
00:27:23,640 --> 00:27:27,000
p7 needs to needs to be quickly finished

518
00:27:27,000 --> 00:27:30,600
so it will start scheduling p7 to

519
00:27:30,600 --> 00:27:33,659
replace p1's slots

520
00:27:33,659 --> 00:27:35,460
so there's many algorithms can do that

521
00:27:35,460 --> 00:27:37,620
okay like for example first circumfers

522
00:27:37,620 --> 00:27:39,539
in right

523
00:27:39,539 --> 00:27:42,059
let's say P1 finish P1 already finished

524
00:27:42,059 --> 00:27:45,480
now it's turned to p7 so ready states

525
00:27:45,480 --> 00:27:49,260
can go to the running space ready states

526
00:27:49,260 --> 00:27:51,900
can easily go to the running stage when

527
00:27:51,900 --> 00:27:54,480
it is history Reddit states can go to

528
00:27:54,480 --> 00:27:56,820
the running stage but it's running stage

529
00:27:56,820 --> 00:28:00,840
able to go to the ready stage

530
00:28:00,840 --> 00:28:03,419
yes it it is right

531
00:28:03,419 --> 00:28:05,880
one for example one any of this running

532
00:28:05,880 --> 00:28:08,520
process they use up their available

533
00:28:08,520 --> 00:28:12,480
slots once CPU already spends a lot of

534
00:28:12,480 --> 00:28:14,700
time on them and it's not their turn

535
00:28:14,700 --> 00:28:17,820
anymore so what happens

536
00:28:17,820 --> 00:28:21,059
they are going to be put back they are

537
00:28:21,059 --> 00:28:23,460
going to be put back into the weight

538
00:28:23,460 --> 00:28:26,700
into the queue into the queue until

539
00:28:26,700 --> 00:28:30,600
anything happens okay and then the what

540
00:28:30,600 --> 00:28:32,460
so it's easy it's very easy to

541
00:28:32,460 --> 00:28:34,020
understand the running stage and the

542
00:28:34,020 --> 00:28:38,240
ready States we can just say right

543
00:28:39,059 --> 00:28:41,640
CPU can hold just a six program at one

544
00:28:41,640 --> 00:28:45,000
time so far if we have 10 programs at

545
00:28:45,000 --> 00:28:46,860
least four programs will be in the right

546
00:28:46,860 --> 00:28:48,900
States sixth program will be in the

547
00:28:48,900 --> 00:28:51,659
running status so always like that then

548
00:28:51,659 --> 00:28:54,860
what about block States

549
00:28:57,240 --> 00:28:59,640
and what about block States

550
00:28:59,640 --> 00:29:02,419
block state

551
00:29:03,000 --> 00:29:05,539
so I hope you can single it for a while

552
00:29:05,539 --> 00:29:10,220
block State okay block state

553
00:29:12,059 --> 00:29:15,659
block the states okay block state

554
00:29:15,659 --> 00:29:19,320
so why we still need block States

555
00:29:19,320 --> 00:29:21,720
by why we didn't suppose this it's like

556
00:29:21,720 --> 00:29:23,880
I'm a driver I'm a driver I like drive

557
00:29:23,880 --> 00:29:26,640
my car I'm always driving the road and

558
00:29:26,640 --> 00:29:27,659
then

559
00:29:27,659 --> 00:29:31,260
one eye one when I see a green light I

560
00:29:31,260 --> 00:29:33,240
drive when I see a red light then I stop

561
00:29:33,240 --> 00:29:35,100
but I'm ready to drive for like I'm

562
00:29:35,100 --> 00:29:36,840
always ready to drive

563
00:29:36,840 --> 00:29:40,200
but why why is those block stays single

564
00:29:40,200 --> 00:29:42,419
of that example right I'm driving the

565
00:29:42,419 --> 00:29:45,980
car in the road yeah

566
00:29:46,080 --> 00:29:49,320
yes the car broke you use up your oil

567
00:29:49,320 --> 00:29:53,039
the car broke the car has some problems

568
00:29:53,039 --> 00:29:55,919
you cannot you are not ready you cannot

569
00:29:55,919 --> 00:29:56,820
run

570
00:29:56,820 --> 00:29:58,679
so you are in the block States that's

571
00:29:58,679 --> 00:30:00,840
the same thing happens in this in in

572
00:30:00,840 --> 00:30:03,779
here process white process has a block

573
00:30:03,779 --> 00:30:06,539
State why process has proxies because

574
00:30:06,539 --> 00:30:08,399
for example a very easy example is that

575
00:30:08,399 --> 00:30:10,980
they are waiting for some inputs they

576
00:30:10,980 --> 00:30:12,840
are waiting for some inputs the impulse

577
00:30:12,840 --> 00:30:15,419
is from is not in the memory the input

578
00:30:15,419 --> 00:30:18,539
needs to come from a let's say a USB a

579
00:30:18,539 --> 00:30:20,340
new inserted USB

580
00:30:20,340 --> 00:30:23,460
from a user user needs to input that the

581
00:30:23,460 --> 00:30:25,740
user is waiting for that the program is

582
00:30:25,740 --> 00:30:28,080
waiting for that so

583
00:30:28,080 --> 00:30:31,140
what will happen we cannot put it

584
00:30:31,140 --> 00:30:33,000
let's say

585
00:30:33,000 --> 00:30:36,419
P2 is this one is this process it's

586
00:30:36,419 --> 00:30:37,740
needs to

587
00:30:37,740 --> 00:30:40,620
after it runs on five minutes in the

588
00:30:40,620 --> 00:30:42,539
program the program says that okay you

589
00:30:42,539 --> 00:30:44,880
need to wait to use those inputs until

590
00:30:44,880 --> 00:30:47,700
the users inputs give the inputs like if

591
00:30:47,700 --> 00:30:49,440
the inputs over the a then you can start

592
00:30:49,440 --> 00:30:52,500
running again so we are going to put P2

593
00:30:52,500 --> 00:30:56,159
if that happens it's like the car use up

594
00:30:56,159 --> 00:30:57,419
all the oil

595
00:30:57,419 --> 00:30:59,399
you have some problems so you can't have

596
00:30:59,399 --> 00:31:01,260
some problems then we put that into the

597
00:31:01,260 --> 00:31:03,360
blog post okay there's a pool there's

598
00:31:03,360 --> 00:31:05,460
port in this review there's Pro there we

599
00:31:05,460 --> 00:31:09,419
put that process in this blocked state

600
00:31:09,419 --> 00:31:11,960
what

601
00:31:14,700 --> 00:31:17,240
here

602
00:31:17,700 --> 00:31:22,279
this is not working you cannot hear me

603
00:31:29,760 --> 00:31:32,760
I I I'll make it closer

604
00:31:32,760 --> 00:31:36,559
is that is that better

605
00:31:40,500 --> 00:31:42,480
okay

606
00:31:42,480 --> 00:31:47,279
it's okay okay so it is in a block state

607
00:31:47,279 --> 00:31:49,440
so we see that it is in the block today

608
00:31:49,440 --> 00:31:52,020
we put that into some block four

609
00:31:52,020 --> 00:31:56,059
okay we put that bro poor

610
00:32:00,000 --> 00:32:03,120
so the running stays can

611
00:32:03,120 --> 00:32:05,039
come to the block States

612
00:32:05,039 --> 00:32:08,700
but is it is it okay to directly put the

613
00:32:08,700 --> 00:32:11,399
block states to the running States

614
00:32:11,399 --> 00:32:15,419
no okay no it's it's it is impossible so

615
00:32:15,419 --> 00:32:17,279
why it is impossible because every

616
00:32:17,279 --> 00:32:19,440
single of that this is not that easy to

617
00:32:19,440 --> 00:32:20,880
understand right

618
00:32:20,880 --> 00:32:22,140
um

619
00:32:22,140 --> 00:32:23,760
it's like your car have some problem

620
00:32:23,760 --> 00:32:26,580
your car you can't use up all the oil so

621
00:32:26,580 --> 00:32:28,679
you need to get some gas and then return

622
00:32:28,679 --> 00:32:30,659
back to the road so same thing comes

623
00:32:30,659 --> 00:32:32,760
into here if the if the process is

624
00:32:32,760 --> 00:32:34,860
pushed into block States

625
00:32:34,860 --> 00:32:37,799
even the process is ready to run it

626
00:32:37,799 --> 00:32:40,140
needs to we need to insert that into the

627
00:32:40,140 --> 00:32:43,559
queue first so it's the ending if after

628
00:32:43,559 --> 00:32:46,260
the block stays if it's ready to run it

629
00:32:46,260 --> 00:32:48,299
needs to go to the

630
00:32:48,299 --> 00:32:50,880
ready States it needs to go to the ready

631
00:32:50,880 --> 00:32:54,779
States now my question is that why so we

632
00:32:54,779 --> 00:32:56,940
know that the running State can go to

633
00:32:56,940 --> 00:32:58,919
the block State block State cannot go

634
00:32:58,919 --> 00:33:00,360
directly to the running State block

635
00:33:00,360 --> 00:33:02,100
States needs to go to the United States

636
00:33:02,100 --> 00:33:03,840
first and go to the

637
00:33:03,840 --> 00:33:07,320
run uh running States right it goes to

638
00:33:07,320 --> 00:33:12,120
block ready running so why we cannot

639
00:33:12,120 --> 00:33:15,179
switch between the ready States tool

640
00:33:15,179 --> 00:33:16,380
boxes

641
00:33:16,380 --> 00:33:18,980
yes

642
00:33:22,380 --> 00:33:27,380
yes yes the the not exactly I'm sorry

643
00:33:27,380 --> 00:33:30,720
the process okay why what we think of

644
00:33:30,720 --> 00:33:32,580
that what is a block State block space

645
00:33:32,580 --> 00:33:36,240
means that I am got blocked I need to I

646
00:33:36,240 --> 00:33:37,740
need to

647
00:33:37,740 --> 00:33:40,019
I'm interrupt right I'm interrupt I need

648
00:33:40,019 --> 00:33:42,539
to get some single to bring me back to

649
00:33:42,539 --> 00:33:46,220
bring me back so

650
00:33:46,559 --> 00:33:50,159
does Os or owning take a look up

651
00:33:50,159 --> 00:33:53,220
the the process running here the running

652
00:33:53,220 --> 00:33:55,679
here the process running here to see if

653
00:33:55,679 --> 00:33:57,659
anyone needs to go to the block States

654
00:33:57,659 --> 00:34:00,899
but the process will not check

655
00:34:00,899 --> 00:34:04,380
will not check the process in the queue

656
00:34:04,380 --> 00:34:06,659
because there will be too much

657
00:34:06,659 --> 00:34:09,780
the queue the program in the queue they

658
00:34:09,780 --> 00:34:11,699
are not running they're not running so

659
00:34:11,699 --> 00:34:14,399
the OS will not check them

660
00:34:14,399 --> 00:34:17,820
think of that so why so that is why we

661
00:34:17,820 --> 00:34:20,520
cannot go from United States to the

662
00:34:20,520 --> 00:34:23,839
block stays okay

663
00:34:33,418 --> 00:34:37,338
so let's take a look at this pic

664
00:34:38,219 --> 00:34:39,918
um

665
00:34:39,918 --> 00:34:42,300
let's take a look at this picture again

666
00:34:42,300 --> 00:34:46,679
see we have three that states right

667
00:34:46,679 --> 00:34:49,800
so running States and ready States

668
00:34:49,800 --> 00:34:54,679
can easily switch between each other

669
00:34:54,839 --> 00:34:57,839
but for running States needs to when it

670
00:34:57,839 --> 00:35:00,180
is blocked this needs to go to the ready

671
00:35:00,180 --> 00:35:03,599
stage first and then goes back to the uh

672
00:35:03,599 --> 00:35:06,680
to the running state

673
00:35:25,440 --> 00:35:28,920
so trans transition one so from ready

674
00:35:28,920 --> 00:35:31,740
states to work states happens when the

675
00:35:31,740 --> 00:35:33,960
operating system discovered that a

676
00:35:33,960 --> 00:35:36,540
process cannot continue right now for

677
00:35:36,540 --> 00:35:39,119
example it needs an input however

678
00:35:39,119 --> 00:35:41,700
there's no input

679
00:35:41,700 --> 00:35:44,880
so that is why running can come from the

680
00:35:44,880 --> 00:35:47,300
Block States

681
00:35:47,300 --> 00:35:51,240
transition 2 and 3 2 scene 2 and 3 are

682
00:35:51,240 --> 00:35:54,480
caused by the process scheduler CPU

683
00:35:54,480 --> 00:35:57,140
scheduler

684
00:35:57,300 --> 00:35:59,339
a CPU scheduler is a part of low

685
00:35:59,339 --> 00:36:02,420
printing systems

686
00:36:02,460 --> 00:36:05,640
so it's it designs some Gathering

687
00:36:05,640 --> 00:36:08,880
algorithms for Earth to best use the CPU

688
00:36:08,880 --> 00:36:11,160
resources so it's all the time sharing

689
00:36:11,160 --> 00:36:13,760
algorithms

690
00:36:19,260 --> 00:36:22,020
um so let's take a look at the

691
00:36:22,020 --> 00:36:25,380
implementation of the process so process

692
00:36:25,380 --> 00:36:27,359
um

693
00:36:27,359 --> 00:36:30,000
the lowest level of the process

694
00:36:30,000 --> 00:36:31,920
structural operating system handled the

695
00:36:31,920 --> 00:36:35,220
interruptions Gathering so above the the

696
00:36:35,220 --> 00:36:38,400
layer are the sequential sequential

697
00:36:38,400 --> 00:36:40,859
process so this is the implementation of

698
00:36:40,859 --> 00:36:43,260
the this is you can think of this is the

699
00:36:43,260 --> 00:36:45,720
architecture of the your CPU okay CPU

700
00:36:45,720 --> 00:36:48,240
scheduling mechanisms so we have a

701
00:36:48,240 --> 00:36:50,880
scheduler and we have many process

702
00:36:50,880 --> 00:36:53,940
running on top of it so the lowest level

703
00:36:53,940 --> 00:36:57,119
means something under the scheduler they

704
00:36:57,119 --> 00:36:59,520
are handling the interrupts and they are

705
00:36:59,520 --> 00:37:02,420
handling the interrupts

706
00:37:02,420 --> 00:37:04,980
how we handle the interrupts we learned

707
00:37:04,980 --> 00:37:08,480
that in our introduction section

708
00:37:08,760 --> 00:37:10,560
how we handle the interrupt when

709
00:37:10,560 --> 00:37:12,300
interrupt happens

710
00:37:12,300 --> 00:37:13,740
um

711
00:37:13,740 --> 00:37:16,339
foreign

712
00:37:19,740 --> 00:37:23,040
so interrupt interrupt we need to we

713
00:37:23,040 --> 00:37:23,940
need to

714
00:37:23,940 --> 00:37:26,700
we need to go from the uh use some of

715
00:37:26,700 --> 00:37:29,220
the kernel mode right and then all as

716
00:37:29,220 --> 00:37:31,859
the CPU has an interrupt Handler right

717
00:37:31,859 --> 00:37:35,940
Handler they are in they are around I

718
00:37:35,940 --> 00:37:38,160
believe it's one more than 100 different

719
00:37:38,160 --> 00:37:40,980
interrupted singles in the OS and there

720
00:37:40,980 --> 00:37:43,200
will be 100 different interrupts

721
00:37:43,200 --> 00:37:44,940
handlers

722
00:37:44,940 --> 00:37:47,820
to catch up this single and then handle

723
00:37:47,820 --> 00:37:50,000
that

724
00:37:50,400 --> 00:37:52,200
now uh

725
00:37:52,200 --> 00:37:55,380
so to implement the process so

726
00:37:55,380 --> 00:37:57,119
implementation the process means that

727
00:37:57,119 --> 00:38:00,300
how we going to if you are the of

728
00:38:00,300 --> 00:38:02,760
software engineering how you're going to

729
00:38:02,760 --> 00:38:06,180
design the OS design the OS so to

730
00:38:06,180 --> 00:38:10,760
implement that implements the process

731
00:38:11,820 --> 00:38:15,000
you need to Define this differential

732
00:38:15,000 --> 00:38:17,880
variables and data structures different

733
00:38:17,880 --> 00:38:21,119
variables and data structures

734
00:38:21,119 --> 00:38:25,700
so let's start from some easy one okay

735
00:38:27,060 --> 00:38:30,060
foreign

736
00:38:32,300 --> 00:38:35,460
we need to have the register program

737
00:38:35,460 --> 00:38:38,579
counter program States word this word

738
00:38:38,579 --> 00:38:40,320
means like it's running stage ready

739
00:38:40,320 --> 00:38:42,240
state rock States right the program

740
00:38:42,240 --> 00:38:44,520
program counter the program counter

741
00:38:44,520 --> 00:38:46,680
means it's a right it's it's another

742
00:38:46,680 --> 00:38:48,720
register it's just saying

743
00:38:48,720 --> 00:38:50,640
how many lines of the code we have run

744
00:38:50,640 --> 00:38:54,660
so far right saved this word like this

745
00:38:54,660 --> 00:38:57,020
and the stack pointer process States

746
00:38:57,020 --> 00:38:59,760
priority what is the priority of the

747
00:38:59,760 --> 00:39:02,700
process process ID parents what is the

748
00:39:02,700 --> 00:39:05,760
parent process ID process group ID the

749
00:39:05,760 --> 00:39:08,180
singles

750
00:39:10,020 --> 00:39:13,140
two-time use chosen CPU time time of the

751
00:39:13,140 --> 00:39:15,680
next alarm

752
00:39:16,560 --> 00:39:19,380
okay so my question is that why we need

753
00:39:19,380 --> 00:39:22,380
to save that CPU time chosen CPU time

754
00:39:22,380 --> 00:39:24,300
time of the next why we need the CPU

755
00:39:24,300 --> 00:39:26,940
time used why we need that why we need

756
00:39:26,940 --> 00:39:29,119
that

757
00:39:29,520 --> 00:39:33,740
why we need to to have that

758
00:39:34,740 --> 00:39:36,660
yes

759
00:39:36,660 --> 00:39:39,480
we want to know how much time the CPU

760
00:39:39,480 --> 00:39:40,500
used

761
00:39:40,500 --> 00:39:42,540
to

762
00:39:42,540 --> 00:39:45,300
to ensure

763
00:39:45,300 --> 00:39:48,920
to run the process in a

764
00:39:50,119 --> 00:39:52,980
so this is used for multi-programming

765
00:39:52,980 --> 00:39:53,780
right

766
00:39:53,780 --> 00:39:55,740
multi-programming because CPU needs to

767
00:39:55,740 --> 00:39:58,859
support multiple process to run so it's

768
00:39:58,859 --> 00:40:01,140
this needs to save the information about

769
00:40:01,140 --> 00:40:03,720
how much time each of the process uses

770
00:40:03,720 --> 00:40:07,260
so far of the my CPUs my CPU resources

771
00:40:07,260 --> 00:40:10,260
but then why CPU needs to save these

772
00:40:10,260 --> 00:40:12,740
resources

773
00:40:14,520 --> 00:40:18,119
if we cannot if if there's no data

774
00:40:18,119 --> 00:40:20,220
structure to save these resources what

775
00:40:20,220 --> 00:40:21,780
will happen

776
00:40:21,780 --> 00:40:24,980
what will happen yeah

777
00:40:25,680 --> 00:40:28,500
yeah you can you cannot make it fair so

778
00:40:28,500 --> 00:40:30,359
the fair here's the thing this is a

779
00:40:30,359 --> 00:40:33,480
tricky word so we have we have many

780
00:40:33,480 --> 00:40:36,599
process let's say we have 10 process I I

781
00:40:36,599 --> 00:40:39,780
have 100 CPU slots it does not mean

782
00:40:39,780 --> 00:40:42,480
everyone needs to get a 10 it does not

783
00:40:42,480 --> 00:40:45,720
mean everyone needs to get 10.

784
00:40:45,720 --> 00:40:48,480
like because some process are not very

785
00:40:48,480 --> 00:40:51,420
high priority process remember when you

786
00:40:51,420 --> 00:40:53,760
run your um you have the experiments

787
00:40:53,760 --> 00:40:56,339
when you open the world uh you you type

788
00:40:56,339 --> 00:40:58,440
something right there's always a demon

789
00:40:58,440 --> 00:41:00,599
process that just runs the back the rest

790
00:41:00,599 --> 00:41:02,160
of the back they are going to doing what

791
00:41:02,160 --> 00:41:03,780
they are going to do checkpointing

792
00:41:03,780 --> 00:41:06,480
they're going to save but it's not safe

793
00:41:06,480 --> 00:41:08,700
every minute you can find out it saves

794
00:41:08,700 --> 00:41:10,859
almost like it depends on how you set it

795
00:41:10,859 --> 00:41:13,079
up if you do not set anything more about

796
00:41:13,079 --> 00:41:16,500
like 5 to 10 minutes right this is save

797
00:41:16,500 --> 00:41:19,380
the current copy your copy you so while

798
00:41:19,380 --> 00:41:21,720
you mistakenly close that you can still

799
00:41:21,720 --> 00:41:24,300
restore that but for that process the

800
00:41:24,300 --> 00:41:26,160
demon process they are actually in a

801
00:41:26,160 --> 00:41:27,960
very low priority

802
00:41:27,960 --> 00:41:31,619
place so they may not get in love CPU

803
00:41:31,619 --> 00:41:33,119
time

804
00:41:33,119 --> 00:41:35,400
here's the example means that is why we

805
00:41:35,400 --> 00:41:37,980
need the CPU time used we also need a

806
00:41:37,980 --> 00:41:40,320
priority right this is easy see this

807
00:41:40,320 --> 00:41:42,000
these two these two are actually working

808
00:41:42,000 --> 00:41:43,200
together

809
00:41:43,200 --> 00:41:46,079
they are ensuring that the process which

810
00:41:46,079 --> 00:41:49,079
is the most important critical one to

811
00:41:49,079 --> 00:41:51,839
get the most of the resource

812
00:41:51,839 --> 00:41:53,820
that is how we implement the process

813
00:41:53,820 --> 00:41:56,099
there

814
00:41:56,099 --> 00:41:58,560
every data structure is designed for a

815
00:41:58,560 --> 00:42:02,060
reason they are not they are not

816
00:42:02,460 --> 00:42:04,500
they are not just simply designed it

817
00:42:04,500 --> 00:42:07,619
okay they are for a reason okay

818
00:42:07,619 --> 00:42:11,240
I will look at this

819
00:42:12,240 --> 00:42:13,560
what is that

820
00:42:13,560 --> 00:42:15,720
the process also needs to maintain the

821
00:42:15,720 --> 00:42:18,900
data structure to save the space of

822
00:42:18,900 --> 00:42:21,800
memory management the pointer to the tax

823
00:42:21,800 --> 00:42:24,480
segments info the pointer to the data

824
00:42:24,480 --> 00:42:27,119
segments import the pointer to the stack

825
00:42:27,119 --> 00:42:29,579
segments info

826
00:42:29,579 --> 00:42:34,040
what is the tax data and the stack

827
00:42:40,880 --> 00:42:43,619
healing it is

828
00:42:43,619 --> 00:42:46,380
here this is a process right when you

829
00:42:46,380 --> 00:42:49,079
loaded that process into the memory into

830
00:42:49,079 --> 00:42:50,940
memory

831
00:42:50,940 --> 00:42:53,280
you put the order variables inputs

832
00:42:53,280 --> 00:42:55,500
outputs the states everything and the

833
00:42:55,500 --> 00:42:57,180
registered program countries everything

834
00:42:57,180 --> 00:42:58,500
and

835
00:42:58,500 --> 00:43:01,560
the priority CPU use you have all these

836
00:43:01,560 --> 00:43:03,420
data structures they are all loaded into

837
00:43:03,420 --> 00:43:04,920
the memory

838
00:43:04,920 --> 00:43:06,900
is why you need a very large memory for

839
00:43:06,900 --> 00:43:08,579
that they're all loaded in your memory

840
00:43:08,579 --> 00:43:10,619
but they are not mixed together they are

841
00:43:10,619 --> 00:43:13,079
not mixed texts together OS is not that

842
00:43:13,079 --> 00:43:16,859
stupid what OS did is that Os or divide

843
00:43:16,859 --> 00:43:19,859
the process data

844
00:43:19,859 --> 00:43:21,240
here

845
00:43:21,240 --> 00:43:23,220
the OS

846
00:43:23,220 --> 00:43:25,079
are going to also did

847
00:43:25,079 --> 00:43:28,160
this is not good

848
00:43:31,859 --> 00:43:34,140
and I say this is your code right this

849
00:43:34,140 --> 00:43:38,060
is your code we're writing a lot of code

850
00:43:38,460 --> 00:43:41,940
so when osc from the O has point of view

851
00:43:41,940 --> 00:43:45,359
we will so I saw a push all the data

852
00:43:45,359 --> 00:43:47,700
together

853
00:43:47,700 --> 00:43:50,520
all the data together

854
00:43:50,520 --> 00:43:53,780
or the texts together

855
00:43:55,200 --> 00:43:57,119
like I wouldn't say that just the code

856
00:43:57,119 --> 00:43:59,700
right your code will command data means

857
00:43:59,700 --> 00:44:01,619
when you're writing a program you set

858
00:44:01,619 --> 00:44:03,839
the valuables the global valuables the

859
00:44:03,839 --> 00:44:07,440
local valuables you write you you give

860
00:44:07,440 --> 00:44:09,420
you have a lot of variables this is like

861
00:44:09,420 --> 00:44:11,819
your inputs you set all all the

862
00:44:11,819 --> 00:44:14,520
variables so the data is there tax code

863
00:44:14,520 --> 00:44:18,540
is there and you have the stack stack is

864
00:44:18,540 --> 00:44:21,780
like during the process is running you

865
00:44:21,780 --> 00:44:24,119
may allocate some memory resources or

866
00:44:24,119 --> 00:44:26,160
delocate some memory resources there all

867
00:44:26,160 --> 00:44:28,140
happens in the stack so what will happen

868
00:44:28,140 --> 00:44:29,240
is that

869
00:44:29,240 --> 00:44:34,760
one process are loaded into the memory

870
00:44:35,520 --> 00:44:39,800
one process is loaded into the memory

871
00:44:40,319 --> 00:44:43,400
we are going to get some

872
00:44:43,400 --> 00:44:46,619
spaces for each of the segments and we

873
00:44:46,619 --> 00:44:48,480
call the segmentation okay we'll call

874
00:44:48,480 --> 00:44:51,180
the segmentation that is why this

875
00:44:51,180 --> 00:44:53,520
process needs to maintain the pointer

876
00:44:53,520 --> 00:44:55,560
for all this

877
00:44:55,560 --> 00:44:57,540
for all these

878
00:44:57,540 --> 00:45:00,000
contacts otherwise the process will

879
00:45:00,000 --> 00:45:01,500
never know

880
00:45:01,500 --> 00:45:03,140
will never know

881
00:45:03,140 --> 00:45:06,560
where it is

882
00:45:10,700 --> 00:45:13,319
there's something tricky here but why

883
00:45:13,319 --> 00:45:15,599
I'm asking questions why the process

884
00:45:15,599 --> 00:45:18,300
needs to save this information

885
00:45:18,300 --> 00:45:20,339
why the process needs to save this

886
00:45:20,339 --> 00:45:22,339
information

887
00:45:22,339 --> 00:45:25,079
why the process data structure needs to

888
00:45:25,079 --> 00:45:27,720
save this information

889
00:45:27,720 --> 00:45:29,819
because the process needs to do the

890
00:45:29,819 --> 00:45:32,460
context switch later so in these two

891
00:45:32,460 --> 00:45:34,800
store this information otherwise the OS

892
00:45:34,800 --> 00:45:37,680
will never know where you were you are

893
00:45:37,680 --> 00:45:40,740
right you are talking to someone

894
00:45:40,740 --> 00:45:42,720
in the morning while you're talking to

895
00:45:42,720 --> 00:45:45,000
the same one at the night you are not

896
00:45:45,000 --> 00:45:48,240
going to talking to to to her start from

897
00:45:48,240 --> 00:45:49,560
the very beginning you are going to pick

898
00:45:49,560 --> 00:45:51,599
up where it is that the same thing

899
00:45:51,599 --> 00:45:54,599
happens in the process process needs to

900
00:45:54,599 --> 00:45:57,000
the OS needs to enable the process to

901
00:45:57,000 --> 00:45:59,400
memorize where they are where they what

902
00:45:59,400 --> 00:46:01,200
is your current state

903
00:46:01,200 --> 00:46:03,660
before the before

904
00:46:03,660 --> 00:46:07,880
scheduling and after the scattering

905
00:46:12,780 --> 00:46:15,780
so this is exactly exactly what happens

906
00:46:15,780 --> 00:46:18,780
when OS processor interrupts okay on OS

907
00:46:18,780 --> 00:46:21,740
process interrupts

908
00:46:22,319 --> 00:46:24,180
so the hardware Stacks the program

909
00:46:24,180 --> 00:46:26,400
counter the hardware loads the new

910
00:46:26,400 --> 00:46:28,200
program counter from the interrupt

911
00:46:28,200 --> 00:46:31,819
Vector the summary number language for

912
00:46:31,819 --> 00:46:34,859
procedure save the registered submarine

913
00:46:34,859 --> 00:46:39,560
language procedure set up the new stack

914
00:46:41,460 --> 00:46:44,579
C interrupts the service runs a schedule

915
00:46:44,579 --> 00:46:47,339
decide which process to run next see

916
00:46:47,339 --> 00:46:49,440
procedure return to the summary code and

917
00:46:49,440 --> 00:46:52,140
summary language procedure startup the

918
00:46:52,140 --> 00:46:54,800
new current process

919
00:46:54,800 --> 00:46:58,079
so to memorize it that is not easy to

920
00:46:58,079 --> 00:46:59,700
understand this is from your textbook

921
00:46:59,700 --> 00:47:01,980
there's a picture there's a picture

922
00:47:01,980 --> 00:47:04,920
together with this in the textbook in

923
00:47:04,920 --> 00:47:06,839
the in the chapter one and also the

924
00:47:06,839 --> 00:47:08,640
chapter the chapter two they all have

925
00:47:08,640 --> 00:47:12,180
the very similar picture uh so are you

926
00:47:12,180 --> 00:47:13,800
trying to understand that I suggest you

927
00:47:13,800 --> 00:47:15,660
to take a look out of this picture

928
00:47:15,660 --> 00:47:18,480
there's no need to

929
00:47:18,480 --> 00:47:21,420
to hard memorize this okay what is that

930
00:47:21,420 --> 00:47:23,060
means

931
00:47:23,060 --> 00:47:26,099
so it's actually very very very easy

932
00:47:26,099 --> 00:47:29,780
just uh we have

933
00:47:31,980 --> 00:47:35,400
so what happens for the process right

934
00:47:35,400 --> 00:47:37,619
for the interrupt what happens for the

935
00:47:37,619 --> 00:47:40,619
interrupt there's two modes lines in the

936
00:47:40,619 --> 00:47:43,079
user mode one is in the current normals

937
00:47:43,079 --> 00:47:46,740
right so let's say I'm running here

938
00:47:46,740 --> 00:47:48,660
this is in memory okay in memory in

939
00:47:48,660 --> 00:47:51,920
memory this is the memory

940
00:47:52,380 --> 00:47:55,500
so my code my process

941
00:47:55,500 --> 00:47:58,260
I'm loading my process here my program

942
00:47:58,260 --> 00:48:00,800
is here

943
00:48:01,079 --> 00:48:04,500
there is in the user mode and then

944
00:48:04,500 --> 00:48:06,780
they also interrupts happen they also

945
00:48:06,780 --> 00:48:08,700
interrupts are happening happening one

946
00:48:08,700 --> 00:48:10,319
interrupts happening

947
00:48:10,319 --> 00:48:14,040
the CPU going to memorize where it is is

948
00:48:14,040 --> 00:48:17,400
if it's the 9 100 so it's memorizing

949
00:48:17,400 --> 00:48:20,579
okay this is the 9 100. we have these

950
00:48:20,579 --> 00:48:23,160
states okay the process the variables

951
00:48:23,160 --> 00:48:25,619
everything everything we say feed in the

952
00:48:25,619 --> 00:48:27,839
process the data structure of the

953
00:48:27,839 --> 00:48:30,060
process right priority the CPU time use

954
00:48:30,060 --> 00:48:33,180
they have everything available and then

955
00:48:33,180 --> 00:48:35,220
and then

956
00:48:35,220 --> 00:48:37,500
we gave the scheduler we gave the

957
00:48:37,500 --> 00:48:39,720
schedule to the CPU so CPU is going to

958
00:48:39,720 --> 00:48:43,260
find out where the interrupts Handler is

959
00:48:43,260 --> 00:48:45,599
so how to find out it is it goes from

960
00:48:45,599 --> 00:48:48,660
user mode to Kernel mode and to find out

961
00:48:48,660 --> 00:48:50,760
to find out the process

962
00:48:50,760 --> 00:48:52,920
the interrupts Handler let's say the

963
00:48:52,920 --> 00:48:57,180
interrupt Handler is running here

964
00:48:57,180 --> 00:48:59,700
is running here so it's going to find

965
00:48:59,700 --> 00:49:01,920
out the Handler after it's and then

966
00:49:01,920 --> 00:49:04,440
handled code run this code run this code

967
00:49:04,440 --> 00:49:06,000
run the handle code I've already

968
00:49:06,000 --> 00:49:08,520
finished so it goes back so this is how

969
00:49:08,520 --> 00:49:12,060
the interruption interrupts works

970
00:49:12,060 --> 00:49:13,859
so this is in the memory this is

971
00:49:13,859 --> 00:49:15,599
actually what happens exactly in the

972
00:49:15,599 --> 00:49:17,760
memory inside of the memory there's

973
00:49:17,760 --> 00:49:21,060
always a special address space

974
00:49:21,060 --> 00:49:24,839
we do not allow anyone to goes into that

975
00:49:24,839 --> 00:49:29,220
is the kernel kernels the OS code okay

976
00:49:29,220 --> 00:49:32,040
that is where we put the active OS code

977
00:49:32,040 --> 00:49:34,560
in that part of the address space this

978
00:49:34,560 --> 00:49:36,780
is in the kernel modes in the kernel so

979
00:49:36,780 --> 00:49:39,540
you interrupt Handler is there interrupt

980
00:49:39,540 --> 00:49:42,200
handle is here

981
00:49:56,300 --> 00:49:59,300
okay okay

982
00:50:05,060 --> 00:50:07,020
okay

983
00:50:07,020 --> 00:50:12,140
okay so let's take a look at this this

984
00:50:18,380 --> 00:50:21,440
yeah yes

985
00:50:28,800 --> 00:50:32,099
we did we didn't discuss that to use

986
00:50:32,099 --> 00:50:33,660
some of the kernel modes we discussed

987
00:50:33,660 --> 00:50:36,660
that in the uh our introduction section

988
00:50:36,660 --> 00:50:40,200
yeah it's still I've already upload my

989
00:50:40,200 --> 00:50:42,660
slides I will also upload the lecture

990
00:50:42,660 --> 00:50:45,780
notes later okay uh so let's look at

991
00:50:45,780 --> 00:50:48,540
this this is a

992
00:50:48,540 --> 00:50:51,480
so how do multi-program performs

993
00:50:51,480 --> 00:50:55,440
um is ask you is asking so it asks you

994
00:50:55,440 --> 00:50:58,619
how to calculate the CPU utilization is

995
00:50:58,619 --> 00:51:01,160
how to calculate the CPU utilization

996
00:51:01,160 --> 00:51:05,280
when multiple programs runs in the

997
00:51:05,280 --> 00:51:08,780
memory multiple program

998
00:51:08,819 --> 00:51:11,460
let's say okay

999
00:51:11,460 --> 00:51:12,740
um

1000
00:51:12,740 --> 00:51:16,200
so degrees of multiple programming means

1001
00:51:16,200 --> 00:51:19,020
that how many how many processes that

1002
00:51:19,020 --> 00:51:20,700
there are many processes that there

1003
00:51:20,700 --> 00:51:22,800
let's look at let's just look at one

1004
00:51:22,800 --> 00:51:24,780
okay before we're looking at the meaning

1005
00:51:24,780 --> 00:51:26,520
we look at we start from the very

1006
00:51:26,520 --> 00:51:28,500
beginning let's see there's only one

1007
00:51:28,500 --> 00:51:30,900
process if there's only one process

1008
00:51:30,900 --> 00:51:35,880
running in our OS and it has

1009
00:51:35,880 --> 00:51:39,839
80 percentage of the i o weights I what

1010
00:51:39,839 --> 00:51:43,559
is IO weight what is ioh

1011
00:51:43,559 --> 00:51:46,579
what is it I always

1012
00:51:55,800 --> 00:51:58,400
yes

1013
00:51:59,000 --> 00:52:02,160
very good very good so I always means

1014
00:52:02,160 --> 00:52:04,079
that uh

1015
00:52:04,079 --> 00:52:07,859
the CPU is the CPU is

1016
00:52:07,859 --> 00:52:10,500
the process is in the block stays the

1017
00:52:10,500 --> 00:52:12,960
speed the process is waiting for some IO

1018
00:52:12,960 --> 00:52:16,440
inputs like inputs and it's it's not

1019
00:52:16,440 --> 00:52:18,540
using the CPU

1020
00:52:18,540 --> 00:52:20,880
it's not using the CPU remember that in

1021
00:52:20,880 --> 00:52:22,619
the when we are in the block States it's

1022
00:52:22,619 --> 00:52:24,420
not in the running state so it's it is

1023
00:52:24,420 --> 00:52:28,500
not using the CPU so one a process has

1024
00:52:28,500 --> 00:52:30,780
80 percentage of the i o weights means

1025
00:52:30,780 --> 00:52:32,700
that the process has all most of the

1026
00:52:32,700 --> 00:52:35,040
time is waiting for the io for example

1027
00:52:35,040 --> 00:52:38,099
the printer is not working the printer

1028
00:52:38,099 --> 00:52:40,800
is waiting for the PDF to be ready okay

1029
00:52:40,800 --> 00:52:43,260
it's like it's same thing like this the

1030
00:52:43,260 --> 00:52:45,900
process is is waiting it's just hands

1031
00:52:45,900 --> 00:52:48,559
there waiting for this waiting for Io

1032
00:52:48,559 --> 00:52:52,819
waiting for some users inputs

1033
00:52:53,579 --> 00:52:56,040
so the superior utilization

1034
00:52:56,040 --> 00:52:58,500
Superior utilization

1035
00:52:58,500 --> 00:53:00,359
in that case

1036
00:53:00,359 --> 00:53:03,660
is 13 percentage why because 80

1037
00:53:03,660 --> 00:53:06,240
percentage of time you are waiting you

1038
00:53:06,240 --> 00:53:08,520
do nothing you do not need you are in

1039
00:53:08,520 --> 00:53:11,160
the blog State you do nothing

1040
00:53:11,160 --> 00:53:14,339
and now if it is the 50 percentage then

1041
00:53:14,339 --> 00:53:16,140
that is one

1042
00:53:16,140 --> 00:53:20,180
minus 15 percentage times with the

1043
00:53:20,180 --> 00:53:25,079
recipient is 50 percentage okay if it is

1044
00:53:25,079 --> 00:53:28,319
20 of your IO makes I always means that

1045
00:53:28,319 --> 00:53:31,380
the CPU is always running so the CPU

1046
00:53:31,380 --> 00:53:34,740
utilization is 80 percentage now this is

1047
00:53:34,740 --> 00:53:36,119
this is

1048
00:53:36,119 --> 00:53:38,640
um this is easy to understand let's look

1049
00:53:38,640 --> 00:53:40,020
at this

1050
00:53:40,020 --> 00:53:43,619
let's look as wonders if there are two

1051
00:53:43,619 --> 00:53:45,720
programs there are two programs there

1052
00:53:45,720 --> 00:53:49,800
are two programs okay two problems then

1053
00:53:49,800 --> 00:53:53,160
if we we are using this formula okay we

1054
00:53:53,160 --> 00:53:56,400
are using this formula with one minus

1055
00:53:56,400 --> 00:53:59,400
this and this is twenty eighty

1056
00:53:59,400 --> 00:54:05,220
percentage of I always right so it's 0.8

1057
00:54:05,220 --> 00:54:08,880
Square okay Square

1058
00:54:08,880 --> 00:54:12,020
so it will be

1059
00:54:15,500 --> 00:54:18,180
36 percentage right

1060
00:54:18,180 --> 00:54:21,660
so why why because why why does a CPU

1061
00:54:21,660 --> 00:54:24,300
utilization is increasing

1062
00:54:24,300 --> 00:54:25,140
um

1063
00:54:25,140 --> 00:54:28,200
because one person we have two process

1064
00:54:28,200 --> 00:54:31,020
one process each of them has 80

1065
00:54:31,020 --> 00:54:34,079
percentage of time of I always when one

1066
00:54:34,079 --> 00:54:38,280
CPU is one process a is waiting for his

1067
00:54:38,280 --> 00:54:42,300
i o the process 2 may need the CPU so

1068
00:54:42,300 --> 00:54:45,420
CPU can help process too same thing one

1069
00:54:45,420 --> 00:54:48,059
process two is waiting on the iOS CPU

1070
00:54:48,059 --> 00:54:49,559
can also process

1071
00:54:49,559 --> 00:54:53,099
a so CPU kind of become more busy busier

1072
00:54:53,099 --> 00:54:56,280
than than the first situation okay

1073
00:54:56,280 --> 00:54:59,040
so my question is that the same thing

1074
00:54:59,040 --> 00:55:01,140
like this if in the in the extreme case

1075
00:55:01,140 --> 00:55:04,200
in the extreme case if we have

1076
00:55:04,200 --> 00:55:06,960
if you have 10 process if we have 10

1077
00:55:06,960 --> 00:55:09,119
process

1078
00:55:09,119 --> 00:55:12,180
10 process then the CPU utilization will

1079
00:55:12,180 --> 00:55:15,960
increase a lot right even even in the 10

1080
00:55:15,960 --> 00:55:18,960
process each of them just

1081
00:55:18,960 --> 00:55:22,020
slightly runs like this pens or 80

1082
00:55:22,020 --> 00:55:24,480
percentage time of I always but what if

1083
00:55:24,480 --> 00:55:25,980
a process

1084
00:55:25,980 --> 00:55:28,980
um or if I have two process okay my

1085
00:55:28,980 --> 00:55:30,720
question is that if I have two process

1086
00:55:30,720 --> 00:55:32,880
the first process have 80 percentage of

1087
00:55:32,880 --> 00:55:34,319
I always

1088
00:55:34,319 --> 00:55:35,579
um

1089
00:55:35,579 --> 00:55:37,819
foreign

1090
00:55:48,680 --> 00:55:51,859
calculate that

1091
00:55:54,059 --> 00:55:56,579
my question is that I have two process

1092
00:55:56,579 --> 00:55:59,280
process one has 80 percentage of IO

1093
00:55:59,280 --> 00:56:01,980
waste process 2 has 50 percentage of I

1094
00:56:01,980 --> 00:56:03,900
always one will be the CPU utilization

1095
00:56:03,900 --> 00:56:06,119
in that case average Super utilization

1096
00:56:06,119 --> 00:56:08,900
in that case

1097
00:56:10,079 --> 00:56:12,859
how much

1098
00:56:14,420 --> 00:56:17,660
how much

1099
00:56:26,040 --> 00:56:28,020
you have

1100
00:56:28,020 --> 00:56:32,960
80 percentage another is 50 percentage

1101
00:56:37,500 --> 00:56:39,480
so a

1102
00:56:39,480 --> 00:56:40,800
is

1103
00:56:40,800 --> 00:56:42,720
100

1104
00:56:42,720 --> 00:56:46,920
CPU utilization is 100 a choice B CPU

1105
00:56:46,920 --> 00:56:49,520
reset engine is 50 percentage

1106
00:56:49,520 --> 00:56:53,040
choices CPU utilization is 20 percentage

1107
00:56:53,040 --> 00:56:56,880
okay 20 distribute is

1108
00:56:56,880 --> 00:56:59,339
60 percentage

1109
00:56:59,339 --> 00:57:03,020
e is 40 percentage

1110
00:57:03,839 --> 00:57:07,040
f is zero

1111
00:57:09,119 --> 00:57:12,839
what will be the answer okay

1112
00:57:12,839 --> 00:57:15,740
I will wait

1113
00:57:16,440 --> 00:57:19,460
this is the

1114
00:57:21,900 --> 00:57:25,280
what's the spiritualization

1115
00:57:36,300 --> 00:57:39,059
we still use this we still just use this

1116
00:57:39,059 --> 00:57:42,000
formula right we still use this formula

1117
00:57:42,000 --> 00:57:44,599
right

1118
00:57:52,319 --> 00:57:55,319
okay so this comes to the uh

1119
00:57:55,319 --> 00:57:58,880
surround okay Suraj

1120
00:58:00,119 --> 00:58:02,640
so go this

1121
00:58:02,640 --> 00:58:05,180
foreign

1122
00:58:21,319 --> 00:58:24,420
structure as the process but however

1123
00:58:24,420 --> 00:58:25,500
there's

1124
00:58:25,500 --> 00:58:28,500
um one key difference is that there's

1125
00:58:28,500 --> 00:58:30,599
one key difference is that

1126
00:58:30,599 --> 00:58:32,599
um

1127
00:58:36,559 --> 00:58:39,660
is more lightweight however from the

1128
00:58:39,660 --> 00:58:43,859
data structure point of view there's

1129
00:58:43,859 --> 00:58:46,440
very important differences between the

1130
00:58:46,440 --> 00:58:49,020
thread and the process the stressing

1131
00:58:49,020 --> 00:58:51,380
process

1132
00:58:53,940 --> 00:58:56,579
so any student knows that

1133
00:58:56,579 --> 00:58:59,480
so if we

1134
00:58:59,760 --> 00:59:02,900
anyone want to try

1135
00:59:05,280 --> 00:59:07,559
but you heard of thread right

1136
00:59:07,559 --> 00:59:09,960
you heard of that right but what is the

1137
00:59:09,960 --> 00:59:11,180
difference

1138
00:59:11,180 --> 00:59:13,079
process

1139
00:59:13,079 --> 00:59:14,900
that's right

1140
00:59:14,900 --> 00:59:17,280
it's very it's very lightweight right

1141
00:59:17,280 --> 00:59:19,079
and we we have the feeling that it is

1142
00:59:19,079 --> 00:59:21,359
lightweight it's easy to create easy to

1143
00:59:21,359 --> 00:59:22,799
delete

1144
00:59:22,799 --> 00:59:25,020
it's very lightweight but what the key

1145
00:59:25,020 --> 00:59:26,940
difference is that

1146
00:59:26,940 --> 00:59:29,579
they actually thread has a very similar

1147
00:59:29,579 --> 00:59:31,920
data structures process if we look at

1148
00:59:31,920 --> 00:59:34,740
the OS code they have very similar but

1149
00:59:34,740 --> 00:59:38,119
what's the differences

1150
00:59:42,440 --> 00:59:45,960
the key difference is is that the key

1151
00:59:45,960 --> 00:59:49,339
difference is with starch

1152
00:59:50,940 --> 00:59:54,599
if the thrust is a process

1153
00:59:54,599 --> 00:59:58,619
is strong if these slots several threads

1154
00:59:58,619 --> 01:00:02,339
they are belonging to the same process

1155
01:00:02,339 --> 01:00:05,099
they are belonging to the same process

1156
01:00:05,099 --> 01:00:08,579
then they they are going to share the

1157
01:00:08,579 --> 01:00:11,819
address space of that process

1158
01:00:11,819 --> 01:00:14,940
and then

1159
01:00:14,940 --> 01:00:16,859
what will happen if they share the

1160
01:00:16,859 --> 01:00:18,900
process the address space what will

1161
01:00:18,900 --> 01:00:20,220
happen

1162
01:00:20,220 --> 01:00:22,799
that is why we say process is very

1163
01:00:22,799 --> 01:00:25,260
lightweighted then the contact switch is

1164
01:00:25,260 --> 01:00:27,720
very easy the contact switch is very

1165
01:00:27,720 --> 01:00:31,559
easy it costs very less overhead and

1166
01:00:31,559 --> 01:00:35,059
let's see why it is okay

1167
01:00:35,420 --> 01:00:38,640
I like the process they have the same

1168
01:00:38,640 --> 01:00:40,980
space like running stage ready stage

1169
01:00:40,980 --> 01:00:43,500
block stays have this have their own

1170
01:00:43,500 --> 01:00:47,339
Stacks same as process okay they have

1171
01:00:47,339 --> 01:00:49,140
their own Stacks they have their own

1172
01:00:49,140 --> 01:00:50,640
data

1173
01:00:50,640 --> 01:00:53,160
they have their own inputs they have

1174
01:00:53,160 --> 01:00:55,740
their own tax they are called

1175
01:00:55,740 --> 01:00:58,760
the same as process

1176
01:01:17,760 --> 01:01:20,280
so if

1177
01:01:20,280 --> 01:01:24,559
if this is your memory okay

1178
01:01:28,559 --> 01:01:30,480
so uh

1179
01:01:30,480 --> 01:01:33,299
a key a differences of my course from

1180
01:01:33,299 --> 01:01:35,640
other uh professors course for the OS is

1181
01:01:35,640 --> 01:01:38,040
that this is also the same as like the

1182
01:01:38,040 --> 01:01:38,760
um

1183
01:01:38,760 --> 01:01:41,099
so in this textbook they actually

1184
01:01:41,099 --> 01:01:44,940
emphasizes a lot on the CPU and memory

1185
01:01:44,940 --> 01:01:48,599
and especially memory because

1186
01:01:48,599 --> 01:01:50,819
everything actually happens in the

1187
01:01:50,819 --> 01:01:52,020
library

1188
01:01:52,020 --> 01:01:54,000
everything that happens happening in the

1189
01:01:54,000 --> 01:01:55,859
memory

1190
01:01:55,859 --> 01:01:58,079
if you understand the memory understand

1191
01:01:58,079 --> 01:02:00,420
the memory data structure and the CPU

1192
01:02:00,420 --> 01:02:03,540
data structure you almost understand the

1193
01:02:03,540 --> 01:02:06,240
whole OS why we when we talking about

1194
01:02:06,240 --> 01:02:08,400
memory you are going to learn a lot of

1195
01:02:08,400 --> 01:02:10,680
algorithms data structures and the

1196
01:02:10,680 --> 01:02:12,720
design decisions then when you're going

1197
01:02:12,720 --> 01:02:14,940
to learn the file system you you can you

1198
01:02:14,940 --> 01:02:17,220
can you you can feel like very surprised

1199
01:02:17,220 --> 01:02:20,220
they are almost exactly the same they

1200
01:02:20,220 --> 01:02:22,440
are almost exactly the same

1201
01:02:22,440 --> 01:02:24,240
they're slightly different they're

1202
01:02:24,240 --> 01:02:25,920
slightly different because these are

1203
01:02:25,920 --> 01:02:28,799
much larger the memory but one day when

1204
01:02:28,799 --> 01:02:31,740
OS designed the memory data structures

1205
01:02:31,740 --> 01:02:34,500
very similar to file system so what are

1206
01:02:34,500 --> 01:02:36,420
most important in the OS Crossing this

1207
01:02:36,420 --> 01:02:39,900
OS course this process and memory they

1208
01:02:39,900 --> 01:02:43,140
are the ultimate ultimates

1209
01:02:43,140 --> 01:02:46,619
importance then memory is the

1210
01:02:46,619 --> 01:02:49,500
abstraction for the hardware of the ram

1211
01:02:49,500 --> 01:02:52,260
right RAM and the process is the

1212
01:02:52,260 --> 01:02:57,059
abstraction forward for CPU okay for CPU

1213
01:02:57,059 --> 01:02:59,760
and for the process when we are talking

1214
01:02:59,760 --> 01:03:02,339
about process we say in the process

1215
01:03:02,339 --> 01:03:07,740
and stress okay stress stress are very

1216
01:03:07,740 --> 01:03:09,900
much lighter weights they are very

1217
01:03:09,900 --> 01:03:11,579
lightweight but you need to understand

1218
01:03:11,579 --> 01:03:14,400
why we say it's lightweight

1219
01:03:14,400 --> 01:03:17,040
why you say this lightweight when we add

1220
01:03:17,040 --> 01:03:19,440
one process when we are creating process

1221
01:03:19,440 --> 01:03:21,900
we allocate the address space for the

1222
01:03:21,900 --> 01:03:24,960
process right but if the process if

1223
01:03:24,960 --> 01:03:28,079
process creates multiple strengths these

1224
01:03:28,079 --> 01:03:30,660
threads are going to share they are not

1225
01:03:30,660 --> 01:03:33,000
going to be in anyone else they are

1226
01:03:33,000 --> 01:03:34,859
there they are they are inside of the

1227
01:03:34,859 --> 01:03:37,020
process the same they are going to share

1228
01:03:37,020 --> 01:03:40,980
the same address space together so when

1229
01:03:40,980 --> 01:03:43,500
you switch when you switch from one

1230
01:03:43,500 --> 01:03:46,079
process one stress to another thread if

1231
01:03:46,079 --> 01:03:47,579
they are belonging to the same process

1232
01:03:47,579 --> 01:03:49,799
only if they belonging to the same

1233
01:03:49,799 --> 01:03:50,880
process

1234
01:03:50,880 --> 01:03:54,240
you do not lead to ask the CPU register

1235
01:03:54,240 --> 01:03:57,059
to do the very complicated scenes like

1236
01:03:57,059 --> 01:03:59,520
take down the numbers take down the

1237
01:03:59,520 --> 01:04:01,319
program counter take on the Knights of

1238
01:04:01,319 --> 01:04:02,940
the code take down your data take down

1239
01:04:02,940 --> 01:04:04,920
the states because everything is the

1240
01:04:04,920 --> 01:04:07,619
same you just need to

1241
01:04:07,619 --> 01:04:10,740
to a easy switch is happening there this

1242
01:04:10,740 --> 01:04:14,839
is why we call stress is lightweight

1243
01:04:35,819 --> 01:04:39,000
so they have their owns that they have

1244
01:04:39,000 --> 01:04:41,520
all their own Stacks oh what's the

1245
01:04:41,520 --> 01:04:43,020
difference between stack and a hip

1246
01:04:43,020 --> 01:04:44,940
what's the difference between a stack

1247
01:04:44,940 --> 01:04:47,420
and a hip

1248
01:04:50,700 --> 01:04:53,240
yes

1249
01:05:04,440 --> 01:05:08,900
I couldn't hear you very clearly

1250
01:05:26,339 --> 01:05:27,660
um

1251
01:05:27,660 --> 01:05:30,059
why why they are or why why is this okay

1252
01:05:30,059 --> 01:05:33,440
let's look at this yeah

1253
01:05:38,579 --> 01:05:40,920
this is a memory right this is your

1254
01:05:40,920 --> 01:05:42,059
memory

1255
01:05:42,059 --> 01:05:43,799
this is your memory let's say we have

1256
01:05:43,799 --> 01:05:46,680
two process P1 and P2

1257
01:05:46,680 --> 01:05:48,839
so what happens what are going to happen

1258
01:05:48,839 --> 01:05:53,059
if you switch from P1 to P2

1259
01:05:53,819 --> 01:05:56,339
what happens you remember the process we

1260
01:05:56,339 --> 01:05:58,319
learned at the very beginning of this

1261
01:05:58,319 --> 01:06:00,599
class the process what is the processor

1262
01:06:00,599 --> 01:06:03,480
running program what is process include

1263
01:06:03,480 --> 01:06:06,480
contains

1264
01:06:07,440 --> 01:06:10,140
variable register problem counters right

1265
01:06:10,140 --> 01:06:14,220
and the inputs outputs States code right

1266
01:06:14,220 --> 01:06:16,980
everything data is in there right when

1267
01:06:16,980 --> 01:06:19,140
you are switching from process one to

1268
01:06:19,140 --> 01:06:21,180
process two

1269
01:06:21,180 --> 01:06:25,099
so who is doing the switching

1270
01:06:26,640 --> 01:06:29,160
CPU is doing that CPU is doing that

1271
01:06:29,160 --> 01:06:33,119
right so CPU how CPU doing that

1272
01:06:33,119 --> 01:06:35,460
what's inside of the CPU in architecture

1273
01:06:35,460 --> 01:06:37,260
course we learned that it was inside of

1274
01:06:37,260 --> 01:06:40,799
CPU yes

1275
01:06:41,340 --> 01:06:44,039
[Music]

1276
01:06:44,039 --> 01:06:46,380
what's inside of a CPU CPU has what's

1277
01:06:46,380 --> 01:06:48,480
inside so you just have two things to

1278
01:06:48,480 --> 01:06:49,559
come

1279
01:06:49,559 --> 01:06:51,839
computational computational components

1280
01:06:51,839 --> 01:06:54,180
right there's a lot of decoding code

1281
01:06:54,180 --> 01:06:56,640
components execute components they're

1282
01:06:56,640 --> 01:06:58,380
running together doing some pipeline

1283
01:06:58,380 --> 01:07:00,660
using some pipeline to run this

1284
01:07:00,660 --> 01:07:03,299
they are they are taking the Beats like

1285
01:07:03,299 --> 01:07:05,579
right you learn that in your company

1286
01:07:05,579 --> 01:07:07,740
course you take they taking the Beats

1287
01:07:07,740 --> 01:07:09,720
doing some xor

1288
01:07:09,720 --> 01:07:13,260
computation rise or and write different

1289
01:07:13,260 --> 01:07:17,359
computations right and xor

1290
01:07:17,880 --> 01:07:20,539
or

1291
01:07:22,079 --> 01:07:24,000
this is a computational component and

1292
01:07:24,000 --> 01:07:26,460
what else register right CPU has a lot

1293
01:07:26,460 --> 01:07:30,359
of registers hundreds of registers

1294
01:07:30,359 --> 01:07:32,460
so when you do this contact switching

1295
01:07:32,460 --> 01:07:34,559
who do who did the contact switch CPU

1296
01:07:34,559 --> 01:07:37,020
did the contact switch right so how CPU

1297
01:07:37,020 --> 01:07:39,299
this contact switch it needs to memorize

1298
01:07:39,299 --> 01:07:41,160
everything inside of

1299
01:07:41,160 --> 01:07:44,579
P1 why you might need to memorize that

1300
01:07:44,579 --> 01:07:46,380
right

1301
01:07:46,380 --> 01:07:48,960
so how should people memorize that

1302
01:07:48,960 --> 01:07:52,200
most of you memorize that it needs to it

1303
01:07:52,200 --> 01:07:55,319
needs to load the information here load

1304
01:07:55,319 --> 01:07:57,240
the information here in the

1305
01:07:57,240 --> 01:08:01,079
help save it save for it save it into

1306
01:08:01,079 --> 01:08:03,960
its registers right registers and then

1307
01:08:03,960 --> 01:08:06,240
some information needs to load needs to

1308
01:08:06,240 --> 01:08:07,619
save in the memory some information

1309
01:08:07,619 --> 01:08:10,380
needs to save in the register and then

1310
01:08:10,380 --> 01:08:13,020
and then it's not loaded the new

1311
01:08:13,020 --> 01:08:15,480
information about P2

1312
01:08:15,480 --> 01:08:18,779
then do the contact switch right

1313
01:08:18,779 --> 01:08:21,899
after P2 finishes it needs to read the

1314
01:08:21,899 --> 01:08:24,000
information in the previous register and

1315
01:08:24,000 --> 01:08:26,279
then goes back to P1 so it can finish

1316
01:08:26,279 --> 01:08:30,060
this switch but if if it is happens in

1317
01:08:30,060 --> 01:08:31,020
this

1318
01:08:31,020 --> 01:08:34,319
in the process in the stress if this if

1319
01:08:34,319 --> 01:08:37,738
stress let's say a process

1320
01:08:37,738 --> 01:08:40,679
he she creates many

1321
01:08:40,679 --> 01:08:43,920
threats she creates many threads then

1322
01:08:43,920 --> 01:08:46,380
they are going to share the same address

1323
01:08:46,380 --> 01:08:47,698
space

1324
01:08:47,698 --> 01:08:49,560
they are going to share the same address

1325
01:08:49,560 --> 01:08:52,439
space the one we are doing the contact

1326
01:08:52,439 --> 01:08:54,120
switch when we are doing the contact

1327
01:08:54,120 --> 01:08:57,299
switch CPU does not need to memorize

1328
01:08:57,299 --> 01:08:59,219
everything

1329
01:08:59,219 --> 01:09:01,439
about this because they shared address

1330
01:09:01,439 --> 01:09:04,560
space they have many things in common

1331
01:09:04,560 --> 01:09:07,020
so when CPU do this contact switch is

1332
01:09:07,020 --> 01:09:08,100
easier

1333
01:09:08,100 --> 01:09:11,399
you think of that you you flying from

1334
01:09:11,399 --> 01:09:14,520
the California to Florida how much

1335
01:09:14,520 --> 01:09:17,279
distance is if you're flying from the

1336
01:09:17,279 --> 01:09:19,560
San Jose to Santa Claus how much

1337
01:09:19,560 --> 01:09:20,880
difference is

1338
01:09:20,880 --> 01:09:23,698
that's the same thing here

1339
01:09:23,698 --> 01:09:25,939
okay

1340
01:09:32,339 --> 01:09:34,940
say again

1341
01:09:39,960 --> 01:09:42,080
how

1342
01:09:42,080 --> 01:09:45,859
E4 difference were

1343
01:09:55,860 --> 01:09:58,320
different process have different data

1344
01:09:58,320 --> 01:10:00,239
right they are still stored in different

1345
01:10:00,239 --> 01:10:02,219
places in the memory

1346
01:10:02,219 --> 01:10:04,500
so CPU has the registers to take down

1347
01:10:04,500 --> 01:10:06,540
this and you process have the data

1348
01:10:06,540 --> 01:10:09,860
structure to store this information

1349
01:10:11,699 --> 01:10:14,340
so let's let's continue okay so what's

1350
01:10:14,340 --> 01:10:16,620
the difference between stack and hip

1351
01:10:16,620 --> 01:10:19,500
stuck on the hip

1352
01:10:19,500 --> 01:10:22,679
here we say the stack

1353
01:10:22,679 --> 01:10:25,880
and the Heap

1354
01:10:26,880 --> 01:10:29,940
so in in the C plus plus course for c c

1355
01:10:29,940 --> 01:10:31,679
cos you

1356
01:10:31,679 --> 01:10:32,699
um

1357
01:10:32,699 --> 01:10:35,360
there is still C chords right

1358
01:10:35,360 --> 01:10:39,300
you still learn zero so he understacked

1359
01:10:39,300 --> 01:10:42,179
so what is the hip

1360
01:10:42,179 --> 01:10:44,760
what difference between hip and stuck so

1361
01:10:44,760 --> 01:10:47,040
stack is used for static memory

1362
01:10:47,040 --> 01:10:49,140
allocation and the hip is for dynamic

1363
01:10:49,140 --> 01:10:51,719
memory allocation right

1364
01:10:51,719 --> 01:10:54,360
so if I'm creating an array now I know

1365
01:10:54,360 --> 01:10:56,580
the size of the array then that will be

1366
01:10:56,580 --> 01:10:59,159
the inner step but if I I didn't know

1367
01:10:59,159 --> 01:11:02,100
the size of the array in

1368
01:11:02,100 --> 01:11:04,020
I have no writing calls for many years

1369
01:11:04,020 --> 01:11:05,760
but I still remember when I write the

1370
01:11:05,760 --> 01:11:09,239
code right there's some um

1371
01:11:09,239 --> 01:11:11,820
vectors or hash tables that are you they

1372
01:11:11,820 --> 01:11:13,020
can dynamically

1373
01:11:13,020 --> 01:11:15,300
allocated that you do not need to

1374
01:11:15,300 --> 01:11:17,640
specify how large it is

1375
01:11:17,640 --> 01:11:19,320
especially in the Java code you do not

1376
01:11:19,320 --> 01:11:21,000
need to specify how large it is right

1377
01:11:21,000 --> 01:11:23,100
you can dynamically allocate the memory

1378
01:11:23,100 --> 01:11:25,560
so that is you how they are used they're

1379
01:11:25,560 --> 01:11:27,480
using the hip and the hip and the stack

1380
01:11:27,480 --> 01:11:28,860
their indifference

1381
01:11:28,860 --> 01:11:32,179
Memorial address

1382
01:11:33,540 --> 01:11:36,780
so how Strat works so if you look at

1383
01:11:36,780 --> 01:11:38,820
this this comment they are very similar

1384
01:11:38,820 --> 01:11:40,500
to

1385
01:11:40,500 --> 01:11:43,440
very similar to the process okay

1386
01:11:43,440 --> 01:11:46,320
so as Grace wrong exists just join the

1387
01:11:46,320 --> 01:11:49,100
yield okay

1388
01:11:53,540 --> 01:11:56,040
we are not going to talk too much about

1389
01:11:56,040 --> 01:11:59,159
that because I'm asking my ITI to to to

1390
01:11:59,159 --> 01:12:01,860
to release the projects about this so

1391
01:12:01,860 --> 01:12:03,659
you are going to practice that in your

1392
01:12:03,659 --> 01:12:06,920
projects like

1393
01:12:09,719 --> 01:12:11,780
um

1394
01:12:13,140 --> 01:12:16,140
almost every on the first of all second

1395
01:12:16,140 --> 01:12:19,080
project about the um textbook about the

1396
01:12:19,080 --> 01:12:22,320
OS textbook they are using the piece

1397
01:12:22,320 --> 01:12:23,820
rats okay

1398
01:12:23,820 --> 01:12:26,159
um we are going to do that too so we are

1399
01:12:26,159 --> 01:12:28,080
going to practice that

1400
01:12:28,080 --> 01:12:29,040
um

1401
01:12:29,040 --> 01:12:31,260
different commands another day

1402
01:12:31,260 --> 01:12:33,260
um

1403
01:12:33,840 --> 01:12:36,540
so to understand the differences between

1404
01:12:36,540 --> 01:12:39,420
joy and a year okay the crazy existing

1405
01:12:39,420 --> 01:12:41,219
these are easy I understand right but

1406
01:12:41,219 --> 01:12:42,420
what is the drawing what is the yield

1407
01:12:42,420 --> 01:12:45,120
okay what is draw on the year is this is

1408
01:12:45,120 --> 01:12:47,340
not that easy but you need to know how

1409
01:12:47,340 --> 01:12:50,719
to do that okay

1410
01:12:51,980 --> 01:12:54,840
then how the process communicates with

1411
01:12:54,840 --> 01:12:57,840
each other is we're using the IPC in the

1412
01:12:57,840 --> 01:13:00,739
process communication

1413
01:13:04,380 --> 01:13:06,600
in the process communication why we need

1414
01:13:06,600 --> 01:13:08,400
to do that why we need process

1415
01:13:08,400 --> 01:13:10,800
communicates why we need forces

1416
01:13:10,800 --> 01:13:13,400
communicates

1417
01:13:13,920 --> 01:13:18,060
why we need IPC

1418
01:13:20,340 --> 01:13:22,800
because we want to make sure that each

1419
01:13:22,800 --> 01:13:25,739
other do not get in

1420
01:13:25,739 --> 01:13:28,080
two or more process do not get in each

1421
01:13:28,080 --> 01:13:31,020
other's way we want to for example put

1422
01:13:31,020 --> 01:13:34,080
two process in

1423
01:13:34,080 --> 01:13:36,719
let's say two people in you are trying

1424
01:13:36,719 --> 01:13:39,840
to get the airplane tickets at the same

1425
01:13:39,840 --> 01:13:41,159
time

1426
01:13:41,159 --> 01:13:43,199
what will happen

1427
01:13:43,199 --> 01:13:45,960
only one can get it the other cannot get

1428
01:13:45,960 --> 01:13:47,580
it right if there's only one seat

1429
01:13:47,580 --> 01:13:49,400
available

1430
01:13:49,400 --> 01:13:53,760
right but how how this happens in the OS

1431
01:13:53,760 --> 01:13:55,260
how OS

1432
01:13:55,260 --> 01:13:57,000
guarantees that

1433
01:13:57,000 --> 01:13:59,340
always guarantees that

1434
01:13:59,340 --> 01:14:01,679
this is a very important concept about

1435
01:14:01,679 --> 01:14:04,860
that we need to ensure that if there's

1436
01:14:04,860 --> 01:14:09,000
many forces they are trying to get some

1437
01:14:09,000 --> 01:14:12,300
same share some share variable they want

1438
01:14:12,300 --> 01:14:14,520
to change some shared variables we need

1439
01:14:14,520 --> 01:14:16,679
to ensure that

1440
01:14:16,679 --> 01:14:19,500
there's no misunderstanding between them

1441
01:14:19,500 --> 01:14:21,780
there's no misunderstanding between them

1442
01:14:21,780 --> 01:14:24,900
so why there's a misunderstanding why

1443
01:14:24,900 --> 01:14:27,120
there is a misunderstanding let's take a

1444
01:14:27,120 --> 01:14:30,560
look at a real life example

1445
01:14:54,659 --> 01:14:57,679
when you're in the team

1446
01:14:58,620 --> 01:15:01,140
this cookie represents

1447
01:15:01,140 --> 01:15:03,739
Disco

1448
01:15:30,239 --> 01:15:33,020
these cookies

1449
01:17:14,000 --> 01:17:16,560
uh well

1450
01:17:16,560 --> 01:17:18,960
I think there's a projector

1451
01:17:18,960 --> 01:17:21,860
issues

1452
01:17:22,080 --> 01:17:24,420
there's actually a very very interesting

1453
01:17:24,420 --> 01:17:27,420
example in of the race condition is a

1454
01:17:27,420 --> 01:17:30,000
real world example it's in my slides so

1455
01:17:30,000 --> 01:17:31,980
it's in the YouTube

1456
01:17:31,980 --> 01:17:33,980
um

1457
01:17:37,020 --> 01:17:40,980
using a YouTube or

1458
01:17:45,320 --> 01:17:50,120
unfortunately there's no way to see that

1459
01:17:54,360 --> 01:17:56,280
oh

1460
01:17:56,280 --> 01:17:59,400
it's like it's it's there you you can

1461
01:17:59,400 --> 01:18:01,199
take a look at it I think it's very

1462
01:18:01,199 --> 01:18:03,719
interesting so I'm going to use another

1463
01:18:03,719 --> 01:18:06,480
example of the of the race Condition

1464
01:18:06,480 --> 01:18:10,520
it's still real life example

1465
01:18:11,280 --> 01:18:13,860
it's still a real life example

1466
01:18:13,860 --> 01:18:14,760
um

1467
01:18:14,760 --> 01:18:18,239
so um we have we have a bank account

1468
01:18:18,239 --> 01:18:21,380
we have a bank account

1469
01:18:23,640 --> 01:18:27,179
we have a bank wait let's say a

1470
01:18:27,179 --> 01:18:29,179
um

1471
01:18:29,280 --> 01:18:34,280
husband and wife are sharing account oh

1472
01:18:34,980 --> 01:18:36,659
husband and wife they are sharing

1473
01:18:36,659 --> 01:18:37,980
accounts they are sharing our bank

1474
01:18:37,980 --> 01:18:40,020
accounts uh

1475
01:18:40,020 --> 01:18:42,239
this is they are sharing bank accounts

1476
01:18:42,239 --> 01:18:44,100
this is their their sharing these bank

1477
01:18:44,100 --> 01:18:48,679
accounts okay they are this is shared

1478
01:18:49,560 --> 01:18:52,080
um so the wife is always earning the

1479
01:18:52,080 --> 01:18:53,040
money

1480
01:18:53,040 --> 01:18:54,659
so I'm going to

1481
01:18:54,659 --> 01:18:57,620
this is a wife

1482
01:18:57,659 --> 01:19:00,360
what's up so she's earning the money so

1483
01:19:00,360 --> 01:19:02,100
she's always

1484
01:19:02,100 --> 01:19:04,920
food surmounting into them into it into

1485
01:19:04,920 --> 01:19:07,380
this shell accounts so every time it's

1486
01:19:07,380 --> 01:19:12,080
like 100 200 100

1487
01:19:12,659 --> 01:19:16,520
so husband is taking the money out

1488
01:19:17,580 --> 01:19:20,580
okay so what he's doing is that he's

1489
01:19:20,580 --> 01:19:23,760
taking 100 200.

1490
01:19:23,760 --> 01:19:26,219
100 whatever there's some money they

1491
01:19:26,219 --> 01:19:28,679
were going to take it out

1492
01:19:28,679 --> 01:19:31,140
so this is how it happens okay they are

1493
01:19:31,140 --> 01:19:34,040
sharing the accounts

1494
01:19:42,300 --> 01:19:45,080
so

1495
01:19:47,820 --> 01:19:51,420
so if if no re what is race condition

1496
01:19:51,420 --> 01:19:53,580
I'll tell you this is the example this

1497
01:19:53,580 --> 01:19:56,460
is just a very uh simple example why the

1498
01:19:56,460 --> 01:20:00,739
they also raise condition okay

1499
01:20:01,320 --> 01:20:03,239
let's say the first time

1500
01:20:03,239 --> 01:20:06,120
the wife earns some money or the a the

1501
01:20:06,120 --> 01:20:08,640
shadow comes is the a okay a equals to

1502
01:20:08,640 --> 01:20:11,940
zero then a becomes like 100 right come

1503
01:20:11,940 --> 01:20:15,679
100 and then if the husband's Deport

1504
01:20:15,679 --> 01:20:20,100
restore the money after the wife

1505
01:20:20,100 --> 01:20:23,159
then the a becomes zero again right same

1506
01:20:23,159 --> 01:20:26,580
thing is here a comma 200.

1507
01:20:26,580 --> 01:20:29,219
and then husbands

1508
01:20:29,219 --> 01:20:33,239
get the money out which become zero

1509
01:20:33,239 --> 01:20:34,679
so

1510
01:20:34,679 --> 01:20:37,800
if they are doing this one by one if

1511
01:20:37,800 --> 01:20:39,480
they are doing this one by one they are

1512
01:20:39,480 --> 01:20:41,400
agree some order

1513
01:20:41,400 --> 01:20:44,520
they algorithm order the accounts will

1514
01:20:44,520 --> 01:20:46,980
be fine the accounts will be fine the

1515
01:20:46,980 --> 01:20:48,840
console will not be broken they will not

1516
01:20:48,840 --> 01:20:52,460
get some penalty from the bank

1517
01:20:53,880 --> 01:20:56,760
but the real reality the

1518
01:20:56,760 --> 01:20:59,100
reality is that we know that what

1519
01:20:59,100 --> 01:21:01,020
husbands knows that the wife is always

1520
01:21:01,020 --> 01:21:03,420
our money and puts the money into the

1521
01:21:03,420 --> 01:21:05,820
bank and so he's

1522
01:21:05,820 --> 01:21:09,360
he just assumed that he she will she

1523
01:21:09,360 --> 01:21:11,820
will do that let's say

1524
01:21:11,820 --> 01:21:14,159
every day sure did that every day so

1525
01:21:14,159 --> 01:21:16,320
sure and the husbands will

1526
01:21:16,320 --> 01:21:18,620
get the money out or get the money out

1527
01:21:18,620 --> 01:21:22,260
but in the case in the case in the case

1528
01:21:22,260 --> 01:21:25,340
they also let's say there's

1529
01:21:25,440 --> 01:21:28,679
something happens in that slice say wife

1530
01:21:28,679 --> 01:21:31,560
and one day for girl to put some money

1531
01:21:31,560 --> 01:21:33,840
into the accounts the husbands is still

1532
01:21:33,840 --> 01:21:35,239
his his

1533
01:21:35,239 --> 01:21:38,820
withdraw a lot of money out

1534
01:21:38,820 --> 01:21:41,699
and they do not they do whatever they

1535
01:21:41,699 --> 01:21:43,440
are doing that they do not let each

1536
01:21:43,440 --> 01:21:46,140
other's know like the husband will not

1537
01:21:46,140 --> 01:21:48,540
ask the wife or have you earned enough

1538
01:21:48,540 --> 01:21:50,520
money into our bank

1539
01:21:50,520 --> 01:21:53,520
can I take it out he will not he will

1540
01:21:53,520 --> 01:21:56,340
they will not have a shared comments

1541
01:21:56,340 --> 01:21:58,320
what they did that what they did

1542
01:21:58,320 --> 01:22:00,000
husbands only knows I would take the

1543
01:22:00,000 --> 01:22:01,980
money out every day because she was

1544
01:22:01,980 --> 01:22:05,520
doing that every day but

1545
01:22:05,520 --> 01:22:09,000
but in the at one at one let's say one

1546
01:22:09,000 --> 01:22:13,860
day Wife puts on forgets to put in love

1547
01:22:13,860 --> 01:22:17,159
money in the accounts but she didn't let

1548
01:22:17,159 --> 01:22:19,560
her husband knows the husbands believe

1549
01:22:19,560 --> 01:22:22,020
that since they are still their minds in

1550
01:22:22,020 --> 01:22:23,940
so he got it out

1551
01:22:23,940 --> 01:22:26,340
that if that happens we call its race

1552
01:22:26,340 --> 01:22:28,739
condition happens the bank account comes

1553
01:22:28,739 --> 01:22:30,900
will be broken they will there will be

1554
01:22:30,900 --> 01:22:33,900
some penalty now

1555
01:22:33,900 --> 01:22:36,600
this this this happens this happens it's

1556
01:22:36,600 --> 01:22:40,320
just a real life example but

1557
01:22:40,320 --> 01:22:43,500
but whatever this happens in the OS in

1558
01:22:43,500 --> 01:22:46,620
OS you know as let's say we have

1559
01:22:46,620 --> 01:22:50,179
still the same example okay

1560
01:22:53,100 --> 01:22:55,679
let's say this is a shared variable this

1561
01:22:55,679 --> 01:22:58,080
is a shared variable this is a shared

1562
01:22:58,080 --> 01:23:00,719
variable let's say the variable is a we

1563
01:23:00,719 --> 01:23:03,179
know multiple process

1564
01:23:03,179 --> 01:23:06,140
we know multiple process

1565
01:23:06,140 --> 01:23:10,020
they are changing the value they are

1566
01:23:10,020 --> 01:23:11,840
changing the value simultaneously

1567
01:23:11,840 --> 01:23:15,060
they'll change the values simultaneously

1568
01:23:15,060 --> 01:23:19,320
and whenever whenever they do it

1569
01:23:19,320 --> 01:23:22,260
this you need to understand based on the

1570
01:23:22,260 --> 01:23:25,560
architecture or combiner knowledge okay

1571
01:23:25,560 --> 01:23:29,960
one p one one p one

1572
01:23:30,719 --> 01:23:33,120
one P1 change the value what will happen

1573
01:23:33,120 --> 01:23:36,300
it needs to there's several operations

1574
01:23:36,300 --> 01:23:38,280
there are several operations the first

1575
01:23:38,280 --> 01:23:41,040
is that it needs to read the current

1576
01:23:41,040 --> 01:23:44,219
value of a and then change the value of

1577
01:23:44,219 --> 01:23:45,179
a

1578
01:23:45,179 --> 01:23:48,480
then returns back so there's several

1579
01:23:48,480 --> 01:23:51,060
operations if we go to the compiler code

1580
01:23:51,060 --> 01:23:54,480
there's at least three operations just

1581
01:23:54,480 --> 01:23:55,620
changing

1582
01:23:55,620 --> 01:23:58,080
changing the a changing the value of a

1583
01:23:58,080 --> 01:24:01,739
there's at least three very tiny CPU

1584
01:24:01,739 --> 01:24:03,719
operations to change the value of a

1585
01:24:03,719 --> 01:24:07,199
let's from the zero to one

1586
01:24:07,199 --> 01:24:10,320
the same thing happens to P2 if P2 needs

1587
01:24:10,320 --> 01:24:12,840
to change some the value of a it needs

1588
01:24:12,840 --> 01:24:15,900
to read the current value of a right it

1589
01:24:15,900 --> 01:24:17,760
needs to read the current value of a

1590
01:24:17,760 --> 01:24:20,520
let's say P2 is read the current copy of

1591
01:24:20,520 --> 01:24:21,900
a

1592
01:24:21,900 --> 01:24:24,600
a equals to one and then let's say P2 is

1593
01:24:24,600 --> 01:24:27,000
doing adding two so it's changed to 2.

1594
01:24:27,000 --> 01:24:30,239
for this is also taking three at least

1595
01:24:30,239 --> 01:24:34,320
three operations same for P3 P4 P5

1596
01:24:34,320 --> 01:24:36,659
so why or what is exactly race condition

1597
01:24:36,659 --> 01:24:39,360
risk condition means that if they are

1598
01:24:39,360 --> 01:24:42,120
they want to changing the value at the

1599
01:24:42,120 --> 01:24:44,580
same time however CPU needs to

1600
01:24:44,580 --> 01:24:48,060
scheduling between this scheduling

1601
01:24:48,060 --> 01:24:50,780
between this

1602
01:24:51,960 --> 01:24:54,300
what it is let's say they're all adding

1603
01:24:54,300 --> 01:24:56,520
one for the a okay they were adding one

1604
01:24:56,520 --> 01:25:00,300
for the tape a for 10 times for 10 times

1605
01:25:00,300 --> 01:25:03,300
so they are doing this concurrently if

1606
01:25:03,300 --> 01:25:06,600
if if the CPU works fine we will get a

1607
01:25:06,600 --> 01:25:08,460
value of a equals to

1608
01:25:08,460 --> 01:25:12,300
15 equals to 15 but the the thing is

1609
01:25:12,300 --> 01:25:16,020
that if we run it 100 times at least one

1610
01:25:16,020 --> 01:25:17,640
time there's a race condition happens

1611
01:25:17,640 --> 01:25:19,500
what is raise condition risk happening

1612
01:25:19,500 --> 01:25:20,880
happens one

1613
01:25:20,880 --> 01:25:24,000
a is changing the P1 is changing the

1614
01:25:24,000 --> 01:25:27,360
value of a changing the value of a but

1615
01:25:27,360 --> 01:25:31,800
before before a P1 has exactly finished

1616
01:25:31,800 --> 01:25:34,080
this so it's these three components

1617
01:25:34,080 --> 01:25:36,239
three Atomic operations to finish

1618
01:25:36,239 --> 01:25:39,179
changing the value of a but just before

1619
01:25:39,179 --> 01:25:41,820
is actually changing the a the J is

1620
01:25:41,820 --> 01:25:44,400
still zero holding after is finished the

1621
01:25:44,400 --> 01:25:46,440
third operation it can change back to

1622
01:25:46,440 --> 01:25:51,480
one but before a is equal to Z1

1623
01:25:51,480 --> 01:25:56,580
CPU scheduling the order from P1 to P2

1624
01:25:56,580 --> 01:26:01,320
from P1 to P2 now when P2 reads it when

1625
01:26:01,320 --> 01:26:04,380
P2 reads the a it will not see a equals

1626
01:26:04,380 --> 01:26:09,320
to 1. it will still see a

1627
01:26:09,860 --> 01:26:12,120
equals to zero

1628
01:26:12,120 --> 01:26:14,520
it will not have a chance to see a

1629
01:26:14,520 --> 01:26:19,380
equals to 1 because 1 8 8 p 1 has not

1630
01:26:19,380 --> 01:26:22,440
yet change it then CPU is already

1631
01:26:22,440 --> 01:26:27,060
scheduling the time slot to P2 so P2 is

1632
01:26:27,060 --> 01:26:29,100
reading A's value and it didn't change

1633
01:26:29,100 --> 01:26:33,239
it so P2 change it to a equals to 1 then

1634
01:26:33,239 --> 01:26:35,639
context which happens

1635
01:26:35,639 --> 01:26:39,960
P2 goes back to P1 P1 change it to one

1636
01:26:39,960 --> 01:26:43,320
then if that happens at the last time we

1637
01:26:43,320 --> 01:26:46,800
get the value of a equals to 49 equals

1638
01:26:46,800 --> 01:26:49,580
to 49.

1639
01:26:50,280 --> 01:26:52,800
why this happens because race condition

1640
01:26:52,800 --> 01:26:54,780
happens while race condition happens

1641
01:26:54,780 --> 01:26:58,440
because they these operations are not

1642
01:26:58,440 --> 01:27:01,800
Atomic and the cpu's scheduling is very

1643
01:27:01,800 --> 01:27:04,760
fast so

1644
01:27:05,780 --> 01:27:07,980
in the textbooks there are some

1645
01:27:07,980 --> 01:27:09,780
explanation of what exactly race

1646
01:27:09,780 --> 01:27:11,580
condition is very long it's very long

1647
01:27:11,580 --> 01:27:13,980
but it does this is the misunderstanding

1648
01:27:13,980 --> 01:27:17,340
the when the CPU scheduling the CPU

1649
01:27:17,340 --> 01:27:21,000
scheduling order is unpredictable

1650
01:27:21,000 --> 01:27:23,219
once we are doing the context switch the

1651
01:27:23,219 --> 01:27:25,620
scheduling is unpredictable

1652
01:27:25,620 --> 01:27:28,800
so contact switch happens in the time

1653
01:27:28,800 --> 01:27:31,679
for each of each of this process finish

1654
01:27:31,679 --> 01:27:34,440
is atomic operation then raise condition

1655
01:27:34,440 --> 01:27:37,260
will happen raise condition will happen

1656
01:27:37,260 --> 01:27:38,880
um

1657
01:27:38,880 --> 01:27:43,580
in our next class we are going to uh

1658
01:27:43,699 --> 01:27:46,800
see this problem again okay so this is

1659
01:27:46,800 --> 01:27:49,139
today's class thank you and please

1660
01:27:49,139 --> 01:27:51,420
remember to do your assignments and do

1661
01:27:51,420 --> 01:27:54,080
your project

